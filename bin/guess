#!/usr/bin/env bash

# used inside and outside of the asgsh environment
#
# D O  N O T   M A N U A L L Y  A D D  P L A T F O R M S  H E R E  A N Y M O R E
# See ./platforms/README
#

export ASGS_LOCAL_DIR=${ASGS_LOCAL_DIR:-.}

BK=$(tput setaf 0)
RD=$(tput setaf 1)
GR=$(tput setaf 2)
YW=$(tput setaf 3)
BL=$(tput setaf 4)
MG=$(tput setaf 5)
CY=$(tput setaf 6)
WH=$(tput setaf 6)
R=$(tput sgr0)
B=$(tput bold)

_guess_platform()
{
  default_platform=unknown
  HOSTNAME=$(hostname --fqdn)

# !!!
# add new platforms to platforms/platforms-lookup.txt
# !!!
  if [ 1 -eq $(echo $HOSTNAME | grep -c qbc) ]; then
    default_platform=queenbeeC
  elif [ 1 -eq $(echo $HOSTNAME | grep -c smic) ]; then
    default_platform=supermic
  elif [ 1 -eq $(echo $HOSTNAME | grep -c frontera) ]; then
    default_platform=frontera
  elif [ 1 -eq $(echo $HOSTNAME | grep -c soldier) ]; then
    default_platform=desktop
  elif [ -n "$WSL_DISTRO_NAME" ]; then
    default_platform=wsl-ubuntu
  fi

  # return if platform is not unknown 
  if [ $default_platform != unknown ]; then
    echo "$default_platform"
    return
  fi

  # IF NOT FOUND ABOVE ... dive into platforms defined in ./platforms/
  local _PLATFORMS=()
  local _BASE=${SCRIPTDIR:-.} # needs to operate outside of asgsh, for ./init-asgs.sh

  # method 1 to find platform - using $_BASE/platforms-lookup.txt
  if [ $default_platform == unknown ]; then
    # look up via the text, find common name that is associated with
    # the matching regular expression that is based on the expected hostname
    local OLDIFS=$IFS
    IFS=$'\n'
    for line in $(cat ${_BASE}/platforms/platforms-lookup.txt | grep -v '#'); do
      local common_name=$(echo $line | awk '{print $1}')
      local hostname_regex=$(echo $line | awk '{print $2}')
      if [[ $(echo $HOSTNAME | egrep -c "$hostname_regex") -eq 1 && -e ${_BASE}/platforms/${common_name}/init.sh ]]; then
        default_platform=$common_name
        break
      fi
    done 
    IFS=$OLDIFS
  fi

  # return if platform is not unknown 
  if [ $default_platform != unknown ]; then
    echo "$default_platform"
    return
  fi

  #TODO 1: should deprecate in favor of platforms-lookup.txt
  # method 2 to find platform - fallback look to list of directories
  if [ $default_platform == unknown ]; then
    if [ -d ${_BASE}/platforms ]; then
      for platform in $(find ${_BASE}/platforms/ -mindepth 1 -maxdepth 1 -type d -exec basename {} \;); do
        _PLATFORMS+=($platform);
      done
      for platform in "${_PLATFORMS[@]}"; do
        if [[ 1 -eq $(echo $HOSTNAME | grep -c $platform) && -e ${_BASE}/platforms/${platform}/init.sh ]]; then
            default_platform=$platform
            break
        fi
      done
    fi
  fi

  # return if platform is not unknown 
  if [ $default_platform != unknown ]; then
    echo "$default_platform"
    return
  fi

  #TODO 2: implement support for $ASGS_LOCAL_DIR/platforms-lookup.txt
  #TODO 3: deprecate method below in favor of platforms-lookup.txt
  # method 3 - supporting locally defined platforms
  # look in $ASGS_LOCAL_DIR, if ENV is set
  if [ $default_platform == unknown ]; then
    if [[ -n "${ASGS_LOCAL_DIR}" && -d ${ASGS_LOCAL_DIR}/platforms ]]; then
      for platform in $(find ${ASGS_LOCAL_DIR}/platforms/ -mindepth 1 -maxdepth 1 -type d -exec basename {} \;); do
        _PLATFORMS+=($platform);
      done
      for platform in "${_PLATFORMS[@]}"; do
        if [[ 1 -eq $(echo $HOSTNAME | grep -c $platform) && -e ${ASGS_LOCAL_DIR}/platforms/${platform}/init.sh ]]; then
            default_platform=$platform
            break
        fi
      done
      if [[ -e ${ASGS_LOCAL_DIR}/platforms/platforms-lookup.txt ]]; then
        # look up via the text, find common name that is associated with
        # the matching regular expression that is based on the expected hostname
        IFS=$'\n'
        for line in $(cat ${ASGS_LOCAL_DIR}/platforms/platforms-lookup.txt | grep -v '#'); do
          local common_name=$(echo $line | awk '{print $1}')
          local hostname_regex=$(echo $line | awk '{print $2}')
          if [[ $(echo $HOSTNAME | egrep -c "$hostname_regex") -eq 1 && -e ${ASGS_LOCAL_DIR}/platforms/${common_name}/init.sh ]]; then
            default_platform=$common_name
            break
          fi
        done
        IFS=$OLDIFS
      fi
    fi
  fi

  # return if platform is not unknown 
  if [ $default_platform != unknown ]; then
    echo "$default_platform"
    return
  fi

  # ultimate fallback is to general OS/linux distro support with
  # tailored batch submission system detection - add as needed, this
  # is not meant to be general support for all OS/batch system combos
  if [ -e /etc/oracle-release ]; then
    default_platform=oracle
  elif [ -e /etc/debian_version ]; then
    default_platform=debian
    local sbatch=$(which sbatch)
    if [ -x "$sbatch" ]; then
      default_platform=debian+slurm
    fi
  elif [ -e /etc/SUSE-brand ]; then
    default_platform=suse
    local qsub=$(which qsub)
    if [ -x "$qsub" ]; then
      default_platform=suse+qsub
    fi
  elif [ -e /etc/redhat-release ]; then
    if [[ $(cat /etc/redhat-release | grep -ic CentOS) == 1 ]]; then 
      default_platform=centos7
    else
      default_platform=rhel
      local qsub=$(which qsub)
      if [ -x "$qsub" ]; then
        default_platform=rhel+pbs
      fi
    fi
  fi

  # return if platform is not unknown 
  if [ $default_platform != unknown ]; then
    echo "$default_platform"
    return
  fi
}

_guess_installation_age()
{
  total_age=0
  file_count=0
  now=$(date +%s)

  while IFS= read -r -d '' file; do
    mtime=$(stat -c %Y "$file")
    age=$((now - mtime))
    total_age=$((total_age + age))
    file_count=$((file_count + 1))
  done < <(find . -maxdepth 1 -type f -print0)

  if [[ file_count == 0 ]]; then
    echo ${W} "No files found in current directory."
    exit 1
  fi

  avg_age=$((total_age / file_count))
  avg_age_days=$((avg_age / 86400))
  avg_time=$(date -d "@$((now - avg_age))")

  echo ${I} "ASGS directory is about ${CY}${B}$avg_age_days${R} days old"
}

_assert_git_repo()
{
  if [[ ! -d "$SCRIPTDIR/.git" ]]; then
    echo ${W} " Health check skipped, .git not found!"
    exit
  fi
}

_guess_health()
{
  _assert_git_repo
  missing=$(git fsck --full 2> /dev/null | grep 'missing' | wc -l)
  if [[ $missing == 0 ]]; then
    echo " ${CY}${B}healthy${R}"
  else
    echo " ${RD}files missing${R}"
  fi
}

_guess(){
  case "${1}" in
    age)
      _guess_installation_age
      ;;
    health)
      _guess_health
      ;;
    platform)
      _guess_platform
      ;;
    *)
      echo "'guess' currently supports only 'guess platform'."
      return
      ;;
  esac
}

_guess $@
