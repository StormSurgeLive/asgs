#!/usr/bin/env perl
#--------------------------------------------------------------------------
# asgs-mon
#--------------------------------------------------------------------------
# Copyright(C) 2024 Brett Estrade
# Copyright(C) 2024 Jason Fleming
#
# This file is part of the ADCIRC Surge Guidance System (ASGS).
#
# The ASGS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ASGS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with the ASGS.  If not, see <http://www.gnu.org/licenses/>.
#--------------------------------------------------------------------------

use ASGSUtil qw//;

package bin::asgs_mon;
use strict;
use warnings;

use Term::ANSIColor qw/:constants colorstrip/;
use JSON::PP        qw/encode_json decode_json/;
use Util::H2O::More qw/ddd Getopt2h2o h2o ini2h2o/;

use constant {
    TIMEOUT      => 30,    # seconds
    CACHE        => {},    # place to store stuff while running
    HUSHTABLE    => {},    # track gag order for notifications
    HUSHLIMIT    => 1800,  # time window gag order is effect
    EXIT_SUCCESS => 0,
    EXIT_ERROR   => 1,

    # plugin exit codes
    OK       => 0,       # no alerts sent
    WARNING  => 1,       # alert sent, subject to notification gag
    CRITICAL => 2,       # alert sent regardless of notification gag (but updates gag table)
    UNKNOWN  => 3,       # alert sent same as WARNING
    NOTIFY   => 4,       # like critical, but used for pure notifications
};

local %ENV = %ENV;

my $ASGS_CONFIG = $ENV{ASGS_CONFIG};
my $ASGS_PID = `ps aux | grep [a]sgs_main.sh | grep "\$ASGS_CONFIG" | awk '{ print \$2 }'`;
my $retcode  = $? >> 8;

if ($retcode != EXIT_SUCCESS) {
  say STDERR (<<EOF);
Error finding asgs_main.sh PID. Exiting ...
EOF
  exit $retcode; 
}
chomp $ASGS_PID;

my $o = Getopt2h2o \@ARGV, { delay => 30, pid => $ASGS_PID }, qw/delay=i foreground hush=i pid=i trace v/;

my $config = ini2h2o sprintf(qq{%s/asgs-global.conf}, ( getpwuid $> )[7]);

# store in %ENV, that is available to all plugins
$ENV{ASGS_PID} = $o->pid;

say STDERR sprintf(<<EOF, $o->pid // q{NONE}, $o->delay);
asgs-mon starting ...
- running checks for asgs_main.sh (pid %s)
- checks happen every %d seconds
EOF

## build up profile, run env info ##
my $info = {};
foreach my $envar (qw/SCRIPTDIR _ASGSH_CURRENT_PROFILE ASGS_CONFIG STATEFILE HPCENVSHORT/) {
    $info->{ lc $envar } = $ENV{$envar};
}

h2o $info, qw/plugindir/;
$info->{plugindir} = sprintf qq{%s/etc/asgs-mon-plugins}, $info->scriptdir;

# get state
my $state = h2o ASGSUtil::state_from_file( $info->statefile );

opendir my $dh, $info->plugindir || die qq{Can't open $info->plugindir: $!};

# get plugins in numerical order, filter out '.' and '..'
my @PLUGINS = map { $_->[0] } sort { $a->[1] <=> $b->[1] } map { [ $_, $_=~/(\d+)/] } grep { !m/^_bash-helper-functions\.sh|^README$|^\.$|^\..$|\.sw.$/ } readdir $dh;

# standard form passed to all scripts
my $hushlimit = $o->hush // HUSHLIMIT;

my $COUNT = 0;
while (1) {
    ++$COUNT;
    foreach my $plugin (@PLUGINS) {
        my $lastout = CACHE->{$plugin}->{output};  # remind plugin what it returned last time
        my $lastret = CACHE->{$plugin}->{retcode}; # remind plugin what it returned last time

        my $PARAMS = sprintf qq{'%s' '%s' '%s' '%s' '%s' '%s' '%s' '%s'}, $lastout // '', $lastret // '', $COUNT, $o->delay, $info->_asgsh_current_profile // '', $info->asgs_config // '', $info->statefile // '', $o->v // 0;

        print qq{Running check: "$plugin"\n} if $o->trace;
        my $plugin_fullpath = sprintf qq{%s/%s}, $info->plugindir, $plugin;
        my $output          = `$plugin_fullpath $PARAMS`; # STDERR is reserved for plugin to output diagnostics
        my $retcode         = $? >> 8;

        # only print to STDOUT if plugin status ins not OK
        if ( $retcode != OK ) {
            my $now = time;
            my $hushed = q{(alert suppressed)};
            if ($retcode == CRITICAL
                or $retcode == NOTIFY 
                or not HUSHTABLE->{$plugin}
                or $now > (HUSHTABLE->{$plugin}+$hushlimit)) {
              notify($plugin, $output);
              HUSHTABLE->{$plugin} = $now;
              $hushed = q{(alert sent)};
            }
            my @lines = split /\n/, $output;
            my $subject = shift @lines;
            # prints the first line of the error message, the whole
            # message (subject + body) gets sent via the notify call
            if ($retcode == CRITICAL) {
              printf STDERR qq{%s%s%s %s\n}, RED, $subject, RESET, $hushed;
            }
            elsif ($retcode == NOTIFY) {
              printf STDERR qq{%s%s%s %s\n}, CYAN, $subject, RESET, $hushed;
            }
            elsif ($retcode == WARNING) {
              printf STDERR qq{%s%s%s %s\n}, YELLOW, $subject, RESET, $hushed;
            }
        }

        # persist check output and persist it in CACHE, saves just the first line due
        # to the way it's passed back in on subsequent calls
        my @output = split /\n/, $output;
        CACHE->{$plugin}->{output}  = shift @output // q{};
        CACHE->{$plugin}->{retcode} = $retcode; 
    }

    # TODO - output some aggregate stats about exit codes, messages sent, etc
    print qq{Status Summary: ... TODO \n};
    print qq{\n};

    sleep $o->delay;
}
closedir $dh;

sub notify {
  my ($plugin, $output) = @_;
  my @lines = map { my $x=colorstrip($_); $x=~s/\(B//g; $x } split /\n/, $output; # also strips Term::ANSIColor codes
  my $subject = shift @lines; # Note: emojis in the subject line come from the plugin's message
  shift @lines; # assume blank
  my $email = $config->monitor->notify_email;
  open my $fh, q{|-}, qq{asgs-sendmail --to "$email" --subject "$subject"};
  my $body = join (qq{\n}, @lines);
  print $fh $body;
  close $fh;
}
