#!/usr/bin/env perl

use strict;
use warnings;

package bin::asgslint;

use Cwd qw/abs_path/;
use Util::H2O::More qw/h2o Getopt2h2o ddd/;

our $VERSION = q{1.0.0};

use constant {
    EXIT_SUCCESS => 0,
    EXIT_ERROR   => 255,
};

# Expected variables in %ENV
my $SCRIPTDIR           = $ENV{SCRIPTDIR};
my $ASGS_CONFIG         = $ENV{ASGS_CONFIG};
my $ADCIRCDIR           = $ENV{ADCIRCDIR};
my $ADCIRC_BINS         = $ENV{ADCIRC_BINS};
my $STATEFILE           = $ENV{STATEFILE};
my $SWANDIR             = $ENV{SWANDIR};
my $MESH_DEFAULTS       = $ENV{ASGS_MESH_DEFAULTS};
my $LOCAL_MESH_DEFAULTS = ($ENV{ASGS_LOCAL_DIR}) ? sprintf(qq{%s/config/mesh_defaults.sh}, $ENV{ASGS_LOCAL_DIR}) : int rand 1_000_000; # security hedge if ASGS_LOCAL_DIR is not defined

# Globals set later
my $ADCIRC_VERSION      = undef;

# C H E C K  S C H E D U L E R
#
#--
#   these checks are names of actual subroutines that are called IN ORDER and the script dies
#   when the *first* FATAL condition is detected; if a subroutine is not defined, then you will
#   get a runtime error; this is something that typically only an ASGS developer will see when
#   updating this linter script

my $assert_checks = {
    fatal_filecheck_ASGS_CONFIG                                      => 1,     # ensures $ASGS_CONFIG exists
    fatal_configcheck_asgsh_vars                                     => 3,     # fatal if any of these exist in config since they are tracked by the profile
    fatal_configcheck_GRIDNAME                                       => 5,     # fatal if GRIDNAME doesn't exist 
    maybe_fatal_configcheck_missing                                  => 8,     # checks $ASGS_CONFIG/ENV for required variables
    fatal_configcheck_FORCINGS                                       => 10,    # sanity check on TROPICALCYCLONE
    fatal_configcheck_CPUs                                           => 15,    # sanity check on requests CPUs
    fatal_configcheck_HOTORCOLD                                      => 20,    # sanity check for configured hotstarts, inspects STATEFILE if exists
    fatal_configcheck_VORTEXMODEL_if_DEFINED                         => 25,    # ensures VORTEXMODEL setting, if defined in config, is consistent with BACKGROUNDMET
    fatal_configcheck_SCENARIOPACKAGESIZE_if_TROPICALCYCLONE_DEFINED => 30,    # sanity check for scenerio package definition, so op doesn't mismatch SCENERIOPACKAGESIZE
    fatal_bincheck_ADCIRC                                            => 35,    # ensures ADCIRC bins are available via PATH
    query_ADCIRC_version                                             => 37,    # sets ADCIRC version, making it available globally
    fatal_configcheck_WAVES_if_on                                    => 40,    # ensures SWAN bins are in PATH no-op if WAVES=off
    fatal_configcheck_get_atcf                                       => 45,    # ensures that TRIGGER and FTPSITE are compatible
    fatal_configcheck_VARFLUX                                        => 50,    # check conditions surrounding river forcing parameter, VARFLUX
};

# N O T E S
#
#  *may be out of sync with the functional source code
#--
#    TRIGGER must be ftp, rss, rssembedded, or atcf.
#    NCPUCAPACITY must be greater than or at least equal to NCPU plus NUMWRITERS for each individual scenario.
#    BACKGROUNDMET set to something other than allowable values : on, NAM, OWI, namBlend,n GFS, gfsBlend, and off.
#    BACKGROUNDMET parameter can only be set to off, namBlend, gfsBlend when TROPICALCYCLONE is set to something other than off.
#    TROPICALCYCLONE and BACKGROUNDMET cannot both be on simultaneously
#    TROPICALCYCLONE and BACKGROUNDMET cannot both be off simultaneously
#    LASTSUBDIR cannot be set to null in the config file if the ASGS is trying to hotstart (i.e., HOTORCOLD=hotstart), and the STATEFILE does not exist.
#    LASTSUBDIR cannot be set to null in the STATEFILE file if it exists and the ASGS is trying to hotstart (i.e., HOTORCOLD=hotstart).
#
#Done, Optional, if defined
#    VORTEXMODEL parameter set to something other than SYMMETRIC, ASYMMETRIC, and GAHM.
#    QUEUESYS must be serial, mpiexec, SLURM, or PBS.
#    VORTEXMODEL parameter set to something other than GAHM when BACKGROUNDMET set to namBlendor gfsBlend.
#    if VARFLUX=on or VARFLUX=default for any ADCIRC version,
#    if WAVES=on and SWANDT is sent in config, it must be in the range, 300 to 1200
#    if WAVES=on and REINITIALIZESWAN is set in config, it must be either 'on' or 'off'
#    if WAVES=on, adcswan and padcswan executables must be available via ADCIRCDIR (exported to environment via ADCIRC config)
#    if WAVES=on, unhcat.exe executables must be available via SWANDIR (exported to environment via ADCIRC config)
#    if WAVES=on, swaninit.template and $SWANTEMPLATE files exist in input/meshes/common/swan under either $SCRIPTDIR
#    ADCIRC ENV checks
#    if TROPICALCYCLONE=on, SCENARIOPACKAGESIZE is checked and some sanity checks on the case/esac structure are done
#    RIVERDATAPROTOCOL is set to one of scp, ftp, or filesystem
#    FTPSITE=filesystem and TRIGGER=ftp is a fatal warning
#    ARCHIVE if defined, must be a file that exists in $SCRIPTDIR/archive
#    ARCHIVEBASE if defined, must be an absolute path (but doesn't have to exist)
#    ARCHIVEDIR if defined, must be a relative path (under ARCHIVEBASE, but doesn't have to exist)
#    if VARFLUX=default then verify that the file $INPUTDIR/$RIVERFLUX exists and has nonzero length
#    if VARFLUX=on or VARFLUX=default and the ADCIRC version is less than v53, then verify that the file $INPUTDIR/$RIVERINIT exists and has nonzero length
#    if VARFLUX=on or VARFLUX=default for any ADCIRC version, verify that the file $INPUTDIR/$HINDCASTRIVERFLUX exists and has nonzero length
#
#TODO - COMPLEX BUT VERY POSSIBLE
#    ??? if VARFLUX=on and USERIVERFILEONLY=no then verify that
#    if RIVERDATAPROTOCOL=scp then verify that the ssh server $RIVERSITE is reachable as the user $RIVERUSER and that the directory $RIVERDIR exists and is readable
#--

my $CONFIG_VARS = {
    INSTANCENAME => {
        ord   => 1,
        req   => 1,
        check => [],
        hint  => q{Must be defined, no spaces},
    },
    ASGSADMIN => { ord => 5, req => 0, check => [], hint => q{must be an email address}, },
    PPN       => {
        ord   => 10,
        req   => 0,
        check => [ \&_INT ],
        hint  => q{Must be integer greater than 0},
    },
    NCPU => {
        ord   => 15,
        req   => 1,
        check => [ \&_INT ],
        hint  => q{Must be integer greater than 0},
    },
    NUMWRITERS => {
        ord   => 20,
        req   => 1,
        check => [ \&_IS_ONE ],
        hint  => q{Must be integer greater than 0 (1 is recommended)},
    },
    NCPUCAPACITY => {
        ord   => 25,
        req   => 1,
        check => [ \&_INT ],
        hint  => q{Must be integer greater than 0},
    },
    QUEUENAME => {
        ord   => 30,
        req   => 0,
        check => [],
        hint  => q{Name of the queue used for parallel compute jobs},
    },
    SERQUEUE => {
        ord   => 35,
        req   => 0,
        check => [],
        hint  => q{Name of the queue used for single processor jobs},
    },
    GRIDNAME => {
        ord   => 40,
        req   => 1,
        check => [],
        hint  => q{name of grid to use},
    },
    BACKGROUNDMET => {
        ord   => 45,
        req   => 1,
        check => [ sub { _IN( @_, qw/on off NAM OWI namBlend GFS gfsBlend/ ) } ],
        hint  => q{Must be: 'on', 'off', 'NAM', 'OWI', 'namBlend', 'GFS', or 'gfsBlend'},
    },
    TROPICALCYCLONE => {
        ord   => 50,
        req   => 1,
        check => [],
        hint  => q{Turn tropical cyclone forcing 'on' or 'off'},
    },
    TRIGGER => {
        ord   => 55,
        req   => 0,
        check => [ sub { _IN( @_, qw/ftp rss rssembedded atcf/ ) } ],
        hint  => q{Must be: 'ftp', 'rss', 'rssembedded', or 'atcf'},
    },
    FTPSITE => {
        ord   => 56,
        req   => 0,
        check => [ sub { \&_DEFER_CHECK } ],
        hint  => q{},
    },
    RSSSITE => {
        ord   => 57,
        req   => 0,
        check => [ sub { \&_DEFER_CHECK } ],
        hint  => q{},
    },
    WAVES => {
        ord   => 60,
        req   => 1,
        check => [ sub { _IN( @_, qw/on off/ ) } ],
        hint  => q{Turns SWAN coupling 'on' or 'off'},
    },
    VARFLUX => {
        ord   => 65,
        req   => 0,
        check => [ sub { _IN( @_, qw/on off default/ ) } ],
        hint  => q{Turns on river flux boundary conditions support in ASGS and ADCIRC.},
    },
    INTENDEDAUDIENCE => {
        ord   => 70,
        req   => 1,
        check => [],
        hint  => q{Control type of notifications, 'dev', 'general', ...},
    },
    POSTPROCESS => {
        ord   => 75,
        req   => 1,
        check => [],
        hint  => q{List of post processing scripts},
    },
    OPENDAPNOTIFY => {
        ord   => 80,
        req   => 0,
        check => [],
        hint  => q{list of *emails notified when OPENDAPPOST is run via POSTPROCESS},
    },
    OPENDAPPOST => {
        ord   => 80,
        req   => 0,
        check => [],
        hint  => q{POSTPROCESS script used by THREDDS integration (used by monitoring/logging.sh)},
    },
    NOTIFY_SCRIPT => {
        ord   => 85,
        req   => 0,
        check => [],
        hint  => q{Script to handle notifications},
    },
    TDS => {
        ord   => 90,
        req   => 0,
        check => [],
        hint  => q{List of thredds servers to upload output},
    },
    COLDSTARTDATE => {
        ord   => 95,
        req   => 1,
        check => [],
        hint  => q{Start date for ramping model from zero state},
    },
    HINDCASTLENGTH => {
        ord   => 100,
        req   => 1,
        check => [],
        hint  => q{Length of time used to cold start},
    },
    HOTORCOLD => {
        ord   => 105,
        req   => 1,
        check => [ sub { _IN( @_, qw/coldstart hotstart/ ) } ],
        hint  => q{Must be: 'coldstart' or 'hotstart'},
    },
    LASTSUBDIR => {
        ord   => 110,
        req   => 1,
        check => [],
        hint  => q{Used when HOTORCOLD is 'hotstart'.},
    },
    SCENARIOPACKAGESIZE => {
        ord   => 115,
        req   => 0,
        check => [ sub { \&_DEFER_CHECK } ],
        hint  => q{specifies number of storms scenarios to be running in addition to a hindcast and a nowcast},
    },
    QUEUESYS => {
        ord   => 120,
        req   => 0,
        check => [ sub { _IN( @_, qw/mpiexec SLURM PBS/ ) } ],
        hint  => q{If defined in config, must be: 'mpiexec', 'SLURM', or 'PBS'.},
    },
    VORTEXMODEL => {
        ord   => 125,
        req   => 0,
        check => [ sub { _IN( @_, qw/SYMMETRIC ASYMMETRIC GAHM/ ) } ],
        hint  => q{If defined in config, must be: 'SYMMETRIC', 'ASYMMETRIC', or 'GAHM'.},
    },
    SWANDT => {
        ord   => 130,
        req   => 0,
        check => [ \&_DEFER_CHECK ],
        hint  => q{If defined and WAVES=on, reasonable values are integers between 300-1200.},
    },
    REINITIALIZESWAN => {
        ord   => 135,
        req   => 0,
        check => [ \&_DEFER_CHECK ],
        hint  => q{If defined and WAVES=on, must be: 'no' or 'yes'.},
    },
    SWANTEMPLATE => {
        ord   => 140,
        req   => 0,
        check => [ \&_DEFER_CHECK ],
        hint  => q{If WAVES=on, swaninit.template and $SWANTEMPLATE files must exist in $SCRIPTDIR/input/meshes/common/swan.},
    },
    EMAILNOTIFY => {
        ord   => 145,
        req   => 1,
        check => [ sub { _IN( @_, qw/yes no/ ) } ],
        hint  => q{must be: 'yes' or 'no'; important for reliably controlling emails sent by POSTPROCESS hook scripts.},
    },
    RIVERDATAPROTOCOL => {
        ord   => 150,
        req   => 0,
        check => [ sub { _IN( @_, qw/scp ftp filesystem/ ) } ],
        hint  => q{must be: 'scp', 'ftp', or 'filesystem' if defined.},
    },
    RIVERSITE => {
        ord   => 151,
        req   => 0,
        check => [ sub { _LOOKS_LIKE_REMOTE_HOST( @_ ) } ],
        hint  => q{If VARFLUX=on, RIVERSITE may be used to define the server from which river boundary data may be gotten as a fort.20.},
    },
    RIVERDIR => {
        ord   => 152,
        req   => 0,
        check => [ \&_DEFER_CHECK ],
        hint  => q{If VARFLUX=on, RIVERDIR may be used to define the directory on RIVERSITE from which river boundary data may be gotten as a fort.20.},
    },
    ARCHIVE => {
        ord   => 155,
        req   => 0,
        check => [ sub { _FILE_EXISTS(@_, qq{$SCRIPTDIR/archive}) } ],
        hint  => q{The file DEFINED by 'ARCHIVE' must exist in $SCRIPTDIR/archive.},
    },
    ARCHIVEBASE => {
        ord   => 160,
        req   => 0,
        check => [ sub { _IS_ABSOLUTE_PATH(@_) } ],
        hint  => q{File path under which $ARCHIVEDIR will be created; ARCHIVEBASE must be an absolute path and will be created if it doesn't exist.},
    },
    ARCHIVEDIR => {
        ord   => 165,
        req   => 0,
        check => [ sub { not _IS_ABSOLUTE_PATH(@_) } ],
        hint  => q{File path unwhich archives will be placed; ADCIRCDIR must be a relative path to $ARCHIVEBASE and will be created if it doesn't exist.},
    },

};

# NONE of these variables should ever appear in a configuration file
my $CONFIG_DISALLOWED = [qw/PERL5LIB LDFLAGS LD_LIBRARY_PATH PERLBREW_HOME ASGS_MESH_DEFAULTS CPPFLAGS PATH LIBRARY_PATH SCRIPTDIR ASGS_PLATFORMS ADCIRCDIR SCRATCH ASGS_BREW_FLAGS PERLBREW_PERL NETCDFHOME ASGS_INSTALL_PATH WORK PERLBREW_PATH PERLBREW_MANPATH MAGICK_HOME ADCIRC_META_DIR ADCIRC_GIT_REPO ASGS_META_DIR LD_RUN_PATH ADCIRC_PROFILE_NAME PERLBREW_ROOT LD_INCLUDE_PATH SWANDIR ASGS_HOME ADCIRC_GIT_BRANCH ASGS_MACHINE_NAME ADCIRC_GIT_URL ADCIRCBASE ASGS_MAKEJOBS PERL_CPANM_HOME ASGS_TMPDIR ASGS_COMPILER ADCIRC_COMPILER _ASGS_EXPORTED_VARS _ASGS_TMP WORK SCRATCH EDITOR PROPERTIESFILE RUNDIR SYSLOG ASGS_CONFIG ADCIRC_MAKE_CMD SWAN_UTIL_BINS_MAKE_CMD ADCSWAN_MAKE_CMD ADCIRC_BINS SWAN_UTIL_BINS ADCSWAN_BINS ADCIRC_BUILD_INFO ASGS_LOCAL_DIR INPUTDIR/];

#
# C H E C K  R O U T I N E S
#

sub fatal_filecheck_ASGS_CONFIG {
    my ( $self, $o ) = @_;
    assert_FATAL(qq{ASGS_CONFIG: not defined.}) if not $ASGS_CONFIG;
    assert_FATAL(
        sprintf qq{ASGS_CONFIG: '%s' doesn't exist or can't be found.},
        $ASGS_CONFIG
    ) if not -e $ASGS_CONFIG;
    return EXIT_SUCCESS;
}

sub fatal_configcheck_asgsh_vars {
    my ( $self, $o ) = @_;

    # fatal if the variable even appears, doesn't need to be defined
    foreach my $var (@$CONFIG_DISALLOWED) {
        my ( $var_found, $value ) = $self->_extract_from_config($var);
        if ($var_found) {
            assert_FATAL(
                sprintf qq{'%s' should not exist in the config file, '%s'.},
                $var, $ASGS_CONFIG
            );
        }
    }

    return 1;
}

sub maybe_fatal_configcheck_missing {
    my ( $self, $o ) = @_;

    # check if missing from config; ENV checks not incorporated yet since the config will override them
    foreach my $var ( sort { $CONFIG_VARS->{$a}->{ord} <=> $CONFIG_VARS->{$b}->{ord} } keys %$CONFIG_VARS ) {

        # ensure all required CONFIG_VARS are defined in ASGS_CONFIG
        if ( $CONFIG_VARS->{$var}->{req} ) {

            # ensures all required (req => 1) variables are defined, skips
            # variables that are not required
            if ( not _DEFINED->( __PACKAGE__, $o, $var ) ) {
                my $hint = sprintf q{%s - %s}, $var, $CONFIG_VARS->{$var}->{hint};
                assert_FATAL(
                    sprintf qq{'%s' not defined in '%s'!\n%s},
                    $var, $ASGS_CONFIG, $hint
                );
            }

            # checks all defined variables, even optional ones; then runs
            # validation routines in the 'checks' field of the CONFIG_VARS hash
        }
        foreach my $check ( @{ $CONFIG_VARS->{$var}->{check} } ) {
            if ( q{CODE} eq ref $check and _DEFINED->( __PACKAGE__, $o, $var ) ) {
                if ( not $check->( __PACKAGE__, $o, $var ) ) {
                    my $hint = sprintf q{%s - %s}, $var, $CONFIG_VARS->{$var}->{hint};
                    assert_FATAL(
                        sprintf qq{'%s' check failed in '%s'!\n%s},
                        $var, $ASGS_CONFIG, $hint
                    );
                }
            }
        }
    }

    return 1;
}

sub fatal_configcheck_FORCINGS {
    my ( $self, $o ) = @_;

    my $var_found;
    ( $var_found, my $BACKGROUNDMET )   = $self->_extract_from_config(q{BACKGROUNDMET});
    ( $var_found, my $TROPICALCYCLONE ) = $self->_extract_from_config(q{TROPICALCYCLONE});

    assert_FATAL(
        sprintf qq{BACKGROUNDMET and TROPICALCYCLONE can't both be the same value},
        $ASGS_CONFIG
    ) if ( $BACKGROUNDMET eq $TROPICALCYCLONE );

    #asgswisdom: BACKGROUNDMET parameter can only be set to off, namBlend, gfsBlend when TROPICALCYCLONE is set to something other than off.
    if ( $TROPICALCYCLONE eq q{off} and grep { $_ =~ m/$BACKGROUNDMET/ } (qw/off namBlend gfsBlend/) ) {
        assert_FATAL(
            sprintf qq{BACKGROUNDMET can't be set to 'off', 'namBlend', 'gfsBlend' if TROPICALCYCLONE is 'off' in '%s'},
            $ASGS_CONFIG
        );
    }

    return 1;
}

sub fatal_configcheck_CPUs {
    my ( $self, $o ) = @_;

    my $var_found;
    ( $var_found, my $PPN )          = $self->_extract_from_config(q{PPN});
    ( $var_found, my $NCPU )         = $self->_extract_from_config(q{NCPU});
    ( $var_found, my $NUMWRITERS )   = $self->_extract_from_config(q{NUMWRITERS});
    ( $var_found, my $NCPUCAPACITY ) = $self->_extract_from_config(q{NCPUCAPACITY});

    #asgswisdom: NCPU+NUMWRITER can't exceed NCPUCAPACITY.
    assert_FATAL(
        sprintf qq{NCPU+NUMWRITER exceeds NCPUCAPACITY in '%s'},
        $ASGS_CONFIG
    ) if ( $NCPU + $NUMWRITERS > $NCPUCAPACITY );

    return 1;
}

sub fatal_configcheck_HOTORCOLD {
    my ( $self, $o ) = @_;

    my $var_found;
    ( $var_found, my $LASTSUBDIR ) = $self->_extract_from_config(q{LASTSUBDIR});
    ( $var_found, my $HOTORCOLD )  = $self->_extract_from_config(q{HOTORCOLD});

    #asgswisdom: LASTSUBDIR cannot be set to null in the config file if the ASGS is trying to hotstart (i.e., HOTORCOLD=hotstart), and the STATEFILE does not exist.
    if ( ( not $LASTSUBDIR or $LASTSUBDIR eq q{null} ) and $HOTORCOLD eq q{hotstart} and ( not $STATEFILE or not -e $STATEFILE ) ) {
        assert_FATAL(
            sprintf qq{LASTSUBDIR can't be 'null' if HOTORCOLD=hotstart in '%s' and STATEFILE doesn't exist.},
            $ASGS_CONFIG
        );
    }

    #asgswisdom: LASTSUBDIR cannot be set to null in the STATEFILE file if it exists and the ASGS is trying to hotstart (i.e., HOTORCOLD=hotstart).
    if ( $STATEFILE and -e $STATEFILE ) {
        my $var_found;
        ( $var_found, my $LASTSUBDIR ) = $self->_extract_from_statefile(q{LASTSUBDIR});
        if ( ( not $LASTSUBDIR or $LASTSUBDIR eq q{null} ) and $HOTORCOLD eq q{hotstart} ) {
            assert_FATAL(
                sprintf qq{LASTSUBDIR can't be 'null' in STATEFILE if HOTORCOLD=hotstart in '%s' and STATEFILE exists.},
                $ASGS_CONFIG
            );
        }
    }

    return 1;
}

# Note: will only check if $VORTEXMODEL is defined, which
# must be accounted for since this is part of the more in-depth
# variable conflict checks
sub fatal_configcheck_VORTEXMODEL_if_DEFINED {
    my ( $self, $o ) = @_;

    my ( $var_found, $BACKGROUNDMET ) = $self->_extract_from_config(q{BACKGROUNDMET});
    ( $var_found, my $VORTEXMODEL ) = $self->_extract_from_config(q{VORTEXMODEL});

    # $VORTEXMODEL is optional and may not be defined
    return EXIT_SUCCESS if not $VORTEXMODEL;

    #asgswisdom: VORTEXMODEL parameter set to something other than GAHM when BACKGROUNDMET set to namBlend.
    if ( $VORTEXMODEL eq q{GAHM} and ($BACKGROUNDMET eq q{namBlend} or $BACKGROUNDMET eq q{gfsBlend} )) {
        assert_FATAL(
            sprintf qq{VORTEXMODEL can't be 'GAHM' when BACKGROUNDMET is 'namBlend' or 'gfsBlend' in '%s'.},
            $ASGS_CONFIG
        );
    }

    return 1;
}

# Note: will only check if $SCENARIOPACKAGESIZE is defined and $TROPICALCYCLONE=YES
sub fatal_configcheck_SCENARIOPACKAGESIZE_if_TROPICALCYCLONE_DEFINED {
    my ( $self, $o ) = @_;

    my ( $var_found, $TROPICALCYCLONE ) = $self->_extract_from_config(q{TROPICALCYCLONE});
    ( $var_found, my $SCENARIOPACKAGESIZE ) = $self->_extract_from_config(q{SCENARIOPACKAGESIZE});

    # $SCENARIOPACKAGESIZE is optional and may not be defined
    return EXIT_SUCCESS if not $TROPICALCYCLONE;

    #asgswisdom: SCENARIOPACKAGESIZE parameter set to something other than GAHM when BACKGROUNDMET set to namBlend.
    if ( $SCENARIOPACKAGESIZE <= 0 and $TROPICALCYCLONE eq q{on} ) {
        assert_FATAL(
            sprintf qq{SCENARIOPACKAGESIZE must be defined and GREATER THAN 0, when TROPICALCYCLONE is 'on' in '%s'.},
            $ASGS_CONFIG
        );
    }

    # get each case from SCENARIOS case/esac
    my $cases = $self->_extract_scenarios_from_config();

    # do some basic inspection

    # "*" (default) case is expected
    if ( not $cases->{q{*}} ) {
        assert_FATAL(
            sprintf qq{final default case "*)" not found in SCENARIOS section. Please adjust '%s' and try again.},
            $ASGS_CONFIG
        );
    }

  CASE_HINDCAST:
    {
        # "-2" (hindcast) is expected
        if ( not $cases->{-2} ) {
            assert_FATAL(
                sprintf qq{hindcast "-2)" not found in SCENARIOS section. Please adjust '%s' and try again.},
                $ASGS_CONFIG
            );
        }

        # get full block present inside of the case statement
        my $CASE_hindcast_block = join qq{\n}, @{ $cases->{-2} };
        my ( $found_ENSTORM, $ENSTORM ) = $self->_extract_from_string( q{ENSTORM}, $CASE_hindcast_block );    # attempt to find value of ENSTORM
        if ( not $found_ENSTORM or $ENSTORM ne q{hindcast} ) {
            assert_FATAL(
                sprintf qq{'ENSTORM=hindcast' not found in SCENARIOS section. Found '$ENSTORM' instead. Please adjust '%s' and try again.},
                $ASGS_CONFIG
            );
        }
    }

  CASE_NOWCAST:
    {
        # "-1" (nowcast) is expected
        if ( not $cases->{-1} ) {
            assert_FATAL(
                sprintf qq{nowcast "-1)" not found in SCENARIOS section. Please adjust '%s' and try again.},
                $ASGS_CONFIG
            );
        }

        # get full block present inside of the case statement
        my $CASE_nowcast_block = join qq{\n}, @{ $cases->{-1} };
        my ( $found_ENSTORM, $ENSTORM ) = $self->_extract_from_string( q{ENSTORM}, $CASE_nowcast_block );    # attempt to find value of ENSTORM
        if ( not $found_ENSTORM or $ENSTORM ne q{nowcast} ) {
            assert_FATAL(
                sprintf qq{'ENSTORM=nowcast' not found in SCENARIOS section. Found '$ENSTORM' instead. Please adjust '%s' and try again.},
                $ASGS_CONFIG
            );
        }
    }

  SCENARIO_COUNT:
    {
        # looking at the number found
        my $expected = $SCENARIOPACKAGESIZE + 1 + 2;                                                         # add in expected -1, -2, & '*'
        my $found    = keys %$cases;

        if ( $expected != $found ) {
            assert_FATAL(
                sprintf qq{SCENARIOPACKAGESIZE is set to %d and is probably wrong. Found %d distinct cases, was expecting %d by this count. Also check case numbering for duplicates. Please adjust '%s' and try again.},
                $SCENARIOPACKAGESIZE, $found, $expected, $ASGS_CONFIG
            );
        }
    }

  SCENARIO_CHECK:
    {
        # check for numbers in sequence (this matters, too)
        foreach my $i ( 0 .. $SCENARIOPACKAGESIZE - 1 ) {

            # assert that cases appear in squence
            if ( not defined $cases->{$i} or not @{ $cases->{$i} } ) {
                assert_FATAL(
                    sprintf qq{Can't find expected SCENARIO Case #$i. SCENARIOS cases must be indexed in order, start at 0. Please adjust '%s' and try again.},
                    $ASGS_CONFIG
                );
            }

            # get full block present inside of the case statement
            my $CASE_block = join qq{\n}, @{ $cases->{$i} };

            my ( $found_ENSTORM, $ENSTORM ) = $self->_extract_from_string( q{ENSTORM}, $CASE_block );    # attempt to find value of ENSTORM
            my ( $found_PERCENT, $PERCENT ) = $self->_extract_from_string( q{PERCENT}, $CASE_block );    # attempt to find value of PERCENT

            # check for valid start patterns: 'nhcC', 'veerLeft', 'veerRight', 'namforecast', 'gfsforecast'
	    my $_PERCENT = $PERCENT // q{};
	    $_PERCENT =~ s/-//g;
            if ( not $ENSTORM or $ENSTORM !~ m/^(nhcC|veerRight$_PERCENT|veerLeft$_PERCENT|namforecast|gfsforecast)/ ) {
                assert_FATAL(
                    sprintf qq{Case "%s" - ENSTORM %s; typically starts with: 'nhcConsensus', 'veerRight$_PERCENT', 'veerLeft$_PERCENT', 'namforecast', 'gfsforecast'. Please adjust '%s' and try again.},
                    $i, ( not $found_ENSTORM ) ? q{is MISSING} : qq{'$ENSTORM' appears INVALID}, $ASGS_CONFIG
                );
            }

            # check PERCENT on Left  (negative)
            if ( $ENSTORM =~ m/Left/ and $PERCENT > 0 ) {
                assert_FATAL(
                    sprintf qq{Case "%s" - PERCENT must be a negative integer for 'veerLeft'. Please adjust '%s' and try again.},
                    $i, $ASGS_CONFIG
                );
            }

            # check PERCENT on Right (positive)
            elsif ( $ENSTORM =~ m/Right/ and $PERCENT < 0 ) {
                assert_FATAL(
                    sprintf qq{Case "%s" - PERCENT must be a positive integer for 'veerRight'. Please adjust '%s' and try again.},
                    $i, $ASGS_CONFIG
                );
            }

        }
    }

    return 1;
}

#  if necessary
sub _extract_mesh_info {
    my ( $self, $cases, $file ) = @_;

    # return without fuss to make it easier to handle when $LOCAL_MESH_DEFAULTS doesn't exist 
    return $cases if not -e $file;

    local $/;
    open my $FH, q{<}, $file || die $!;
    my $config = <$FH>;

    my $START  = 0;
    my @cases  = ();
    my @names  = ();

  LINE:
    foreach my $line ( split /\n/, $config ) {
        last LINE if ( $line =~ m/^esac/ );
        ++$START  if ( $line =~ m/^case/ );
        next LINE unless  $START > 0;
        if ( $line =~ m/^ *([0-9a-zA-Z"_-|*]+)\)/ ) {
            my $case = $1;                   # get capture
            $case =~ s/["']//g;              # remove quotes
            @names = split / *\| */, $case;  # split cases that have multiple names
            next LINE;
        }
        next LINE if not @names;

        # add an entry for each name at the expense space
        foreach my $case (@names) {
          push @{ $cases->{$case} }, $line;
        }

        # detect line 
        if ( $line =~ m/;;/ ) {
            @names = ();
        }
    }

    close $FH;
    return $cases;
}

sub _extract_scenarios_from_config {
    my ( $self ) = @_;

    local $/;
    open my $FH, q{<}, $ASGS_CONFIG || die $!;
    my $config = <$FH>;
    my $START  = 0;
    my $cases  = {};
    my @cases  = ();
  LINE:
    foreach my $line ( split /\n/, $config ) {
        last LINE if ( $line =~ m/^esac/ );
        ++$START  if ( $line =~ m/^SCENARIOPACKAGESIZE/ );
        next LINE if not $START;
        ++$START  if ( $line =~ m/^case/ );
        next LINE if 2 > $START;
        if ( $line =~ m/^ *(-?\d)\)/ or $line =~ m/^ *(\*)\)/ ) {
            my $index = $1;
            push @cases, $index;
            next LINE;
        }
        if ( $#cases >= 0 ) {
            if ( $line =~ m/;;/ ) {
                $line .= q{ # <~ end of case};
            }
            push @{ $cases->{ $cases[-1] } }, $line;
        }
    }
    close $FH;
    return $cases;
}

sub fatal_bincheck_ADCIRC {
    my ( $self, $o ) = @_;

    #asgswisdom: ADCIRCDIR and ADCIRC_BINS must be available in the environment.
    if ( not $ADCIRCDIR or not $ADCIRC_BINS ) {
        assert_FATAL(q{ADCIRCDIR and ADCIRC_BINS must be available in the environment.});
    }

    #asgswidom: All binaries listed in ADCIRC_BINS must exist in ADCIRCDIR and be in PATH
    foreach my $bin ( split /\s+/, $ADCIRC_BINS ) {
        if ( not $self->_BIN_OK( $ADCIRCDIR, $bin ) ) {
            assert_FATAL( sprintf qq{$bin is not found, but is required to be available via PATH to continue.} );
        }
    }

    return 1;
}

# run after fatal_bincheck_ADCIRC
sub query_ADCIRC_version {
    $ADCIRC_VERSION = `adcirc -v`;
    return $ADCIRC_VERSION;
};

sub fatal_configcheck_WAVES_if_on {
    my ( $self, $o ) = @_;

    my $var_found;
    ( $var_found, my $WAVES ) = $self->_extract_from_config(q{WAVES});
    return EXIT_SUCCESS if ( $WAVES eq q{off} );

    #asgswisdom: If WAVES=on and SWANDT is sent in config, it must be in the range, 300 to 1200
    ( $var_found, my $SWANDT ) = $self->_extract_from_config(q{SWANDT});
    if ( $SWANDT and not $self->_IS_IN_RANGE( q{SWANDT}, 300, 1200 ) ) {
        assert_FATAL(
            sprintf qq{SWANDT must be defined if WAVES=on, in the range 300-1200, in '%s'.},
            $ASGS_CONFIG
        );
    }

    #asgswisdom: If WAVES=on and REINITIALIZESWAN is set in config, it must be either 'on' or 'off'
    ( $var_found, my $REINITIALIZESWAN ) = $self->_extract_from_config(q{REINITIALIZESWAN});
    if ( not $self->_DEFINED( $o, q{REINITIALIZESWAN}, qw/yes no/ ) ) {
        assert_FATAL(
            sprintf qq{REINITIALIZESWAN must be defined if WAVES=on, must be 'yes' or 'no', in '%s'.},
            $ASGS_CONFIG
        );
    }

    #asgswisdom: If WAVES=on, adcswan and padcswan executables must be available via ADCIRCDIR (exported to environment via ADCIRC config)
    if (   not $ADCIRCDIR
        or not $self->_BIN_OK( $ADCIRCDIR, q{adcswan} )
        or not $self->_BIN_OK( $ADCIRCDIR, q{padcswan} ) ) {
        assert_FATAL( sprintf qq{adcswan and padswan are required if WAVES=on, via ADCIRCDIR which should be preferably defined in the environment.} );
    }

    #asgswisdom: If WAVES=on, unhcat.exe executables must be available via SWANDIR (exported to environment via ADCIRC config)
    if (   not $SWANDIR
        or not -x sprintf( q{%s/%s}, $SWANDIR, q{unhcat.exe} )
        or system(q{which unhcat.exe > /dev/null 2>&1}) != EXIT_SUCCESS ) {
        assert_FATAL( sprintf qq{unhcat.exe required if WAVES=on, via SWANDIR which should be preferably defined in the environment.} );
    }

    #asgswisdom: If WAVES=on, swaninit.template and $SWANTEMPLATE files exist in input/meshes/common/swan under either $SCRIPTDIR
    ( $var_found, my $SWANTEMPLATE ) = $self->_extract_from_config(q{SWANTEMPLATE});
    if (
        $var_found
        and (  not -e sprintf( q{%s/%s}, $SCRIPTDIR, q{swaninit.template} )
            or not -e sprintf( q{%s/%s}, $SCRIPTDIR, $SWANTEMPLATE ) )
    ) {
        assert_FATAL( $CONFIG_VARS->{SWANTEMPLATE}->{hint} );
    }

    return 1;
}

sub fatal_configcheck_get_atcf {
    my ( $self, $o ) = @_;

    my $var_found;
    ( $var_found, my $TRIGGER ) = $self->_extract_from_config(q{TRIGGER});
    ( $var_found, my $FTPSITE ) = $self->_extract_from_config(q{FTPSITE});

    #asgswisdom: FTPSITE can't be 'filesystem' when TRIGGER=ftp
    if ($FTPSITE and $TRIGGER and $FTPSITE eq q{filesystem} and $TRIGGER eq q{ftp}) { 
      assert_FATAL( qq{'TRIGGER=ftp' is not compatible with 'FTPSITE=filesystem'.} );
    }

    return 1;
}

# extracts information out of the mesh_default's file based on GRIDNAME
sub _get_grid_info {
  my ($self, $GRIDNAME) = @_;

  my $meshes = __PACKAGE__->_extract_mesh_info( {}, $MESH_DEFAULTS);
  $meshes    = __PACKAGE__->_extract_mesh_info( $meshes, $LOCAL_MESH_DEFAULTS);

  $meshes->{$GRIDNAME} //= [];

  my $block  = join qq{\n}, @{$meshes->{$GRIDNAME}};

  return $block;
}

# expands in a string, a given SHELL variable name and it's value
sub _expand_shell_var {
  my ($self, $string, $VAR, $value) = @_;

  return $string if not $string; # don't process undefined things

  # expand SCRIPTDIR (limit case of variables available for expansion)
  $string =~ s/\$?{?$VAR}?/$value/;
  return $string; 
}


sub fatal_configcheck_GRIDNAME {
    my ( $self, $o ) = @_;
    my $var_found;
    ( $var_found, my $GRIDNAME) = $self->_extract_from_config(q{GRIDNAME});
    my $grid_info               = $self->_get_grid_info($GRIDNAME);

    if ( not $grid_info )  {
      assert_FATAL( sprintf qq{GRIDNAME '%s' can't be found.}, $GRIDNAME );
    }

    return 1;
}

# VARFLUX checks are rather convoluted, so we may need to break this up
sub fatal_configcheck_VARFLUX {
    my ( $self, $o ) = @_;

    # get GRIDNAME
    my ( $var_found, $GRIDNAME)   = $self->_extract_from_config(q{GRIDNAME});

    # get grid info
    my $mesh_info                 = $self->_get_grid_info($GRIDNAME);

    # get VARFLUX
    ( $var_found, my $VARFLUX)    = $self->_extract_from_config(q{VARFLUX});

    # get following from mesh_defaults only (may need to put a check in later if every placed in config file)
    ( $var_found, my $INPUTDIR)           = $self->_extract_from_string(q{INPUTDIR}, $mesh_info);
    ( $var_found, my $RIVERFLUX)          = $self->_extract_from_string(q{RIVERFLUX}, $mesh_info);
    ( $var_found, my $RIVERINIT)          = $self->_extract_from_string(q{RIVERINIT}, $mesh_info);
    ( $var_found, my $HINDCASTRIVERFLUX)  = $self->_extract_from_string(q{HINDCASTRIVERFLUX}, $mesh_info);

    # expand SCRIPTDIR (limit case of variables available for expansion)
    $INPUTDIR = $self->_expand_shell_var($INPUTDIR, q{SCRIPTDIR}, $SCRIPTDIR);

    #asgswisdom: if VARFLUX is 'on' or 'default' & ADCIRC version is < v53, $INPUTDIR/$RIVERINIT must exist and not be empty 
    if ( $VARFLUX and ( grep {/$VARFLUX/} qw/on default/) and $RIVERINIT and $RIVERINIT ne q{null} ) {
      my $file = sprintf qq{%s/%s}, $INPUTDIR, $RIVERINIT; 
      $ADCIRC_VERSION =~ m/v(\d+)/; # attempt to extract number after "v", e.g., "v52" or "v53"
      my $adcv = $1 // 1_000_000;   # if no capture, set to high value
      if ( $adcv < 53 and not -e $file or not -s $file) { # note: -s is the file test flag for size
        assert_FATAL( q{When VARFLUX=on or default, A& ADCIRC version < v53, ${INPUTDIR}/${RIVERINIT} must exist and not be empty.});
      }
    }

    #asgswisdom: if VARFLUX=default then $INPUTDIR/$RIVERFLUX must exist and not be empty 
    if ( $VARFLUX and $VARFLUX eq q{defined} and $RIVERFLUX and $RIVERFLUX ne q{null} ) {
      my $file = sprintf qq{%s/%s}, $INPUTDIR, $RIVERFLUX; 
      if ( not -e $file or not -s $file) { # note: -s is the file test flag for size
        assert_FATAL( q{When VARFLUX=default, ${INPUTDIR}/${RIVERFLUX} must exist and not be empty.});
      }
    }

    #asgswisdom: if VARFLUX=on or VARFLUX=default for any ADCIRC version, $INPUTDIR/$HINDCASTRIVERFLUX must exist and not be empty 
    if ( $VARFLUX and ( grep {/$VARFLUX/} qw/on default/) and $HINDCASTRIVERFLUX and $HINDCASTRIVERFLUX ne q{null} ) {
      my $file = sprintf qq{%s/%s}, $INPUTDIR, $HINDCASTRIVERFLUX; 
      if ( not -e $file or not -s $file) { # note: -s is the file test flag for size
        assert_FATAL( q{When VARFLUX=on or default, A& ADCIRC version < v53, ${INPUTDIR}/${HINDCASTRIVERFLUX} must exist and not be empty.});
      }
    }

    return 1;
}

#
# V A L I D A T I O N  R O U T I N E S
#

# "no op", just used in variable config for clarity
sub _DEFER_CHECK {
    my ( $self, $o, $var ) = @_;
    return 1;
}

# does -x check on full path to binary + checks it's
# in path using system's `which`
sub _BIN_OK {
    my ( $self, $base_path, $bin_name ) = @_;
    if ( not -x sprintf( q{%s/%s}, $base_path, $bin_name )
        or system(qq{which $bin_name > /dev/null 2>&1}) != EXIT_SUCCESS ) {
        return undef;
    }
    return 1;
}

# tests to see if variable exists in config and is a member of a set
# of values
sub _IN {
    my ( $self, $o, $var, @valid_list ) = @_;
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);
    if ( not $CFG_VALUE or not grep { $_ =~ m/^$CFG_VALUE$/ } @valid_list ) {
        return undef;
    }
    return 1;
}

# tests to see if variable is an integer
sub _INT {
    my ( $self, $o, $var ) = @_;
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);
    if ( int $CFG_VALUE < 1 ) {
        return undef;
    }
    return 1;
}

# tests to see if variable is == 1
sub _IS_ONE {
    my ( $self, $o, $var ) = @_;
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);
    if ( int $CFG_VALUE != 1 ) {
        return undef;
    }
    return 1;
}

# tests to see if variable is in a range, inclusive
sub _IS_IN_RANGE {
    my ( $self, $o, $var, $min, $max ) = @_;
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);
    if ( int $CFG_VALUE < $min or int $CFG_VALUE > $max ) {
        return undef;
    }
    return 1;
}

# TRUE if "$var=" is found in ASGS_CONFIG or if the
# $ENV{$var} hash key exists (but is not necessarily defined)
# because in both cases, it is available for asgs_main.sh and all child
# processes to use
sub _exists {
    my ( $self, $var ) = @_;
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);
    if ( $CFG_VALUE or $ENV{$var} ) {
        return 1;
    }
    return undef;
}

# true if the variable _exists_ and is also defined
sub _DEFINED {
    my ( $self, $o, $var ) = @_;

    # $var existing is a necessary condition
    return undef if not $self->_exists($var);

    # now check if it's actually defined (i.e., not undef)
    my ( $var_found, $CFG_VALUE ) = $self->_extract_from_config($var);

    # diagnotic output when -v is set
    printf STDERR qq{(INFO: _DEFINED sub): %-20s is "%s" \n}, $var, $CFG_VALUE // q{undefined} if $o->v;

    if ( not $var_found or not defined $CFG_VALUE ) {
        return undef;
    }
    return 1;
}

# tests to see if directory exists

sub _DIR_EXISTS {
    my ( $self, $o, $var, $subdir ) = @_; 
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);
    my $file = ($subdir) ? qq{$subdir/$CFG_VALUE} : qq{$CFG_VALUE};
    if ( not -d $file ) {
      return undef;
    }
    return 1;
}

sub _FILE_EXISTS {
    my ( $self, $o, $var, $subdir ) = @_; 
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);
    my $file = ($subdir) ? qq{$subdir/$CFG_VALUE} : qq{$CFG_VALUE};
    if ( not -e $file ) {
      return undef;
    }
    return 1;
}

sub _IS_ABSOLUTE_PATH {
    my ( $self, $o, $var ) = @_; 
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);
    if ( not $CFG_VALUE =~ m/^\// ) {
      return undef;
    }
    return 1;
}

sub _LOOKS_LIKE_REMOTE_HOST {
    my ( $self, $o, $var ) = @_; 
    my $var_found;
    ( $var_found, my $CFG_VALUE ) = $self->_extract_from_config($var);

    # fails if $CFG_VALUE is not a valid hostname or IPv4 IP address
    if ( not $CFG_VALUE =~ m/^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/
         and not $CFG_VALUE =~ m/^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/) {
      return undef;
    }
    return 1;
}

#
# U T I L I T Y  R O U T I N E S
#

# returns a list; first variable is if the $var exists in $ASGS_CONFIG; the
# second is the value of the assignment (undef if anything is on the RHS of
# the '='
sub _extract_from_string {
    my ( $self, $varname, $text ) = @_;
    $text =~ m/^\s*($varname)=([\w."\)\(\$}{\/:-]+)\s*#?/m;
    return ( $1, $2 );
}

sub _extract_from_config {
    my ( $self, $varname ) = @_;
    local $/;
    open my $FH, q{<}, $ASGS_CONFIG || die $!;
    my $config = <$FH>;
    close $FH;
    return $self->_extract_from_string( $varname, $config );
}

# asgswisdom: STATEFILE should only be defined in the environment and set by asgs_main.sh
sub _extract_from_statefile {
    my ( $self, $varname ) = @_;

    # short circuit if not yet defined (will be the case for brand new profiles)
    return undef if not $STATEFILE;

    local $/;
    open my $FH, q{<}, $STATEFILE || die $!;
    my $state = <$FH>;
    close $FH;
    return $self->_extract_from_string( $varname, $state );
}

sub assert_FATAL($) {
    my $MSG = shift;
    warn qq{(!!! assert_FATAL): $MSG\n ... fix and rerun linter\n};
    exit EXIT_ERROR;
}

sub _show_help {
    print <<EOHELP;

asgs-lint ($VERSION) ... A very strict, static ASGS configuration file checker.

Quick Start - no options are required if ASGS_CONFIG is set:

  1. ./asgsh
  2. load profile # (select profile) 
  3. asgs-lint    # command is available via PATH
  4. if asgs-lint finds an issue with the config it'll exit;
     fix the issue and rerun until there are no more issues
     found


Description:

  Run inside of asgsh with a profile loaded, without any options ASGS_CONFIG
  is examined for required or highly recommended settings. asgs-lint fails
  on the first problem found. Fix the problem, then run again - until there
  are no more issues found.

  This tool is a static analysis tool; meaning it examines the text of ASGS_CONFIG
  and any files contained herein as long as the file paths may be determined
  with out executing or `source`'ing any shell scripts.

Advanced Usage:

  --help                         This help text
  --config path/to/config.sh     Check a config other than ASGS_CONFIG
  --list vars                    Summary of required variables and descriptions
  --list disallowed              Summary of variables forbidden to be skipping file: '900': no matches found
in ASGS_CONFIG,
                                 because they conflict with important environmental variables

Maintenance Note:

This script is meant to be updated whenever new static checks
are needed; usually as a result of a long debugging session that
could have been caught using a static checker tool like this one.

EOHELP
}

#
# M A I N  D R I V E R
#

sub run {
    my ($argv) = @_;
    local %ENV = %ENV;

    my $o = Getopt2h2o \@ARGV, {}, qw/config=s help list=s v/;

    my $self = bless {}, __PACKAGE__;

    if ( $o->help ) {
        $self->_show_help;
        return EXIT_SUCCESS;
    }

    if ( $o->list and $o->list eq q{vars} ) {
        foreach my $var ( sort { $CONFIG_VARS->{$a}->{ord} <=> $CONFIG_VARS->{$b}->{ord} } keys %$CONFIG_VARS ) {
            my $req = ( $CONFIG_VARS->{$var}->{req} ) ? q{[required]} : q{[optional]};
            printf qq{%s %-19s %s\n}, $req, $var, $CONFIG_VARS->{$var}->{hint};
        }
        return EXIT_SUCCESS;
    }

    if ( $o->list and $o->list eq q{disallowed} ) {
        foreach my $var (@$CONFIG_DISALLOWED) {
            printf qq{%s\n}, $var;
        }
        return EXIT_SUCCESS;
    }

    if ( $o->config ) {
        $ASGS_CONFIG = $o->config;
        printf qq{Linting configuration file, '%s' ...\n}, $ASGS_CONFIG;
    }

  DO_FATAL:
    foreach my $check ( sort { $assert_checks->{$a} <=> $assert_checks->{$b} } keys %$assert_checks ) {
        $self->$check($o);
    }

    return EXIT_SUCCESS;
}

exit run( \@ARGV // [] ) if not caller;

1;
