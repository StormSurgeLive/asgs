#!/bin/bash
#------------------------------------------------------------------------
# opendap_post2.sh : Makes results available to thredds data server.
#------------------------------------------------------------------------
# Copyright(C) 2015--2019 Jason Fleming
#
# This file is part of the ADCIRC Surge Guidance System (ASGS).
#
# The ASGS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ASGS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with the ASGS.  If not, see <http://www.gnu.org/licenses/>.
#------------------------------------------------------------------------
#
THIS=$(basename -- $0)
source $SCRIPTDIR/monitoring/logging.sh
#
EXIT_SUCCESS=0
EXIT_ERROR=1
sendEmail="no"
declare -A properties
SCENARIODIR=$PWD
RUNPROPERTIES=$SCENARIODIR/run.properties
if [[ $# -eq 1 ]]; then
   RUNPROPERTIES=$1
   SCENARIODIR=`dirname $RUNPROPERTIES`
   MANUAL=1
fi
# this script can be called with just one command line option: the
SCRIPTDIR=`sed -n 's/[ ^]*$//;s/path.scriptdir\s*:\s*//p' $RUNPROPERTIES`
source $SCRIPTDIR/properties.sh

# load run.properties file into associative array
loadProperties $RUNPROPERTIES
RUNDIR=${properties['path.rundir']}        # parent directory of all runs created by asgs_main.sh, $RUNDIR in asgs_main.sh, asgsh
SSHLOGFILE=$RUNDIR/ssh-server.log       # primary log target for this script
consoleMessage "${I} $THIS: error log is set to '$SSHLOGFILE'"

if [ -z "$OPENDAPNOTIFY" ]; then
  OPENDAPNOTIFY=${properties['notification.opendap.email.opendapnotify']}
   logMessage "Email list via 'OPENDAPNOTIFY' is '$OPENDAPNOTIFY'" $SSHLOGFILE
fi

CONFIG=${properties['config.file']}
COLDSTARTDATE=${properties["adcirc.time.coldstartdate"]} # used for the hindcast path
CYCLEDIR=${properties['path.advisdir']}     # directory from where ADCIRC is actually running
CYCLE=${properties['advisory']}
# if this is an initialization, there is no advisory number
# to use in the opendap path
if [[ ${properties['advisory']} = "0" ]]; then
   CYCLE=$COLDSTARTDATE
else
   # this does not actually seem to be used in this script
   HSTIME=${properties['InitialHotStartTime']}
fi
HPCENV=${properties['hpc.hpcenv']}
SCENARIO=${properties['scenario']}
SYSLOG=${properties['monitoring.logging.file.syslog']}
CYCLELOG=${properties['monitoring.logging.file.cyclelog']}
SCENARIOLOG=${properties['monitoring.logging.file.scenariolog']}
source $SCRIPTDIR/platforms.sh

#+ vvvvv
# BEGIN - get list of servers for scp'ing files, uses
# a key in the scenarios run.properties,
#   + post.opendap.tds
#
serverList=$(echo ${properties['post.opendap.tds']} | tr -d "()")
IFS=' ' read -r -a SERVERS <<< "$serverList"
#
# END
# ^^^^^

# assert there are server targets (at least 1)
if [[ ${#SERVERS[@]} -eq 0 ]]; then
   MSG="cycle $CYCLE: $SCENARIO: $THIS: No opendap servers in $RUNPROPERTIES."
   consoleMessage "${W} $MSG" $SSHLOGFILE
   exit
fi

#+ vvvvv
# BEGIN - determine what files to upload, takes into
# consideration files written in the scenario's run.properties
# file, using 2 keys:
#   + post.opendap.files           - generated by output/createOPeNDAPFileList.sh
#   + post.opendap.additionalFiles - specified by user config via "postAdditionalFiles"
#   + post.opendap.excludeFiles    - specified by user config via "postExcludeFiles"
#

# standard files included
fileList=$(echo ${properties["post.opendap.files"]} | tr -d "()")
IFS=' ' read -r -a FILES_Standard <<< "$fileList"

# additional files included, customized via config file "postAdditionalFiles"
additionalFileList=$(echo ${properties["post.opendap.additionalFiles"]} | tr -d "()")
IFS=' ' read -r -a FILES_Additional <<< "$additionalFileList"

# files to exclude from overall list, customized via config file "postExcludeFiles"
excludeFileList=$(echo ${properties["post.opendap.excludeFiles"]} | tr -d "()")
IFS=' ' read -r -a FILES_Exclude <<< "$excludeFileList"
# process excludeFileList
declare -A excludeLookUp
for _exclude in ${FILES_Exclude[*]}; do
  # use md5sum to get a unique hash for the file NAME (not content!) as listed via "post.opendap.files"
  # because the special characters in file names can't be used as keys in bash associative arrays;
  # the hash is prepended with an abitrary string 'MD5' because some hashes begin with an integer,
  # and bash interprets these as array indexes
  nameHash=MD5$(echo $_exclude | md5sum -t | awk '{print $1}')
  excludeLookUp+=([$nameHash]="$_exclude");
done

_FILES=( "${FILES_Standard[@]}" "${FILES_Additional[@]}" ) # NOTE: duplicates are not removed or detected
#
# END - determine what files to upload, takes into
#+ ^^^^^

# now filter out any files that do not exist
FILES=()
sendNotification=
for _file in ${_FILES[*]}; do
  # check for 'sendNotification' tracer before `readlink -f` which requires a real file
  if [[ $_file == "sendNotification" ]]; then
    sendNotification=$_file
    FILES+=($_file)
    continue
  fi
  # skipping file if mdfsum of $_file (before `readlink -f`)
  _check_md5=MD5$(echo $_file | md5sum -t | awk '{print $1}')
  if [[ ${excludeLookUp[$_check_md5]+_} ]]; then
    echo "Skipping $(readlink -f $_file) because it's in postExcludeFiles"
    continue
  fi
  # readlink will resolve $_file to a full path
  _file=$(readlink -f $_file)
  if [[ -e $_file ]]; then
    FILES+=($_file)
  else
    MSG="cycle $CYCLE: $SCENARIO: $THIS: Can't find '$_file', which is listed in in $RUNPROPERTIES."
    consoleMessage "${W} $MSG" $SSHLOGFILE
  fi
done

# warn if sendNotification is not found
# otherwise add as last item in array so it
# send when done with all files ...
if [[ -z $sendNotification ]]; then
    MSG="cycle $CYCLE: $SCENARIO: $THIS: 'sendNotification' tracer not found in file list."
    consoleMessage "${W} $MSG" $SSHLOGFILE
fi

# assert there are files to upload
if [[ ${#_FILES[@]} -eq 0 ]]; then
   MSG="cycle $CYCLE: $SCENARIO: $THIS: No files to post to opendap servers in $RUNPROPERTIES."
   logMessage "$MSG" $SSHLOGFILE
   exit
fi
if [[ $SCENARIO == "asgs.instance.status" ]]; then
   statusDir=${properties['path.statusdir']}
   cd ${statusDir} > errmsg 2>&1 || logMessage "$SCENARIO: $THIS: Failed to change directory to '$statusDir'" $SSHLOGFILE
   sendEmail="no"
else
   cd ${SCENARIODIR} > errmsg 2>&1 || logMessage "cycle $CYCLE: $SCENARIO: $THIS: Failed to change directory to '$SCENARIODIR'" $SSHLOGFILE
   if [[ -z $OPENDAPNOTIFY || $OPENDAPNOTIFY == "" || $OPENDAPNOTIFY == "null" ]]; then
      sendEmail="no"
   else
      sendEmail="yes"
   fi
fi

# load asgs operator email address
ASGSADMIN=${properties["notification.email.asgsadmin"]}
ASGSADMIN_ID=${properties["notification.email.asgsadmin_id"]}
GRIDNAME=${properties["adcirc.gridname"]}
INSTANCENAME=${properties["instancename"]}
HPCENVSHORT=${properties["hpc.hpcenvshort"]}
TROPICALCYCLONE=${properties["forcing.tropicalcyclone"]}
BACKGROUNDMET=${properties["forcing.backgroundmet"]}

# support UUID for email subject
_ASGSADMIN_ID=$ASGSADMIN_ID
if [[ -z "$_ASGSADMIN_ID" ||  "$_ASGSADMIN_ID" == "null" ]]; then
  _ASGSADMIN_ID=$ASGSADMIN
fi

# get the scenario number
SCENARIONUMBER=${properties["scenario.number"]} # this is used in the subject line of the email
env_dispatch $HPCENVSHORT # set up JOBENV with perlbrew for asgs-sendmail etc
OPENDAPMAILSERVER=${properties["notification.opendap.email.opendapmailserver"]}
declare -a LINKABLEHOSTS
declare -a COPYABLEHOSTS
timeoutRetryLimit=${timeoutRetryLimit:-5} # FIXME: hardcoded to 5; make this more granular
serverAliveInterval=${serverAliveInterval:-10}

sendEmail_orig=$sendEmail
for server in ${SERVERS[*]}; do
   if [[ $server = "(" || $server = ")" ]]; then
      continue
   fi
   consoleMessage "${I} cycle $CYCLE: $SCENARIO: $THIS: Posting to opendap server ${server}."
   # write platform-dependent properties related to posting to thredds server for
   # opendap service  (from platforms.sh)
   writeTDSProperties $server $RUNPROPERTIES  # this writes TDS properties to the properties file

   # FIXME: enable Operator to override TDS parameter settings from platforms.sh
   _THIS="output/opendap_post2.sh-->$server"
   loadProperties $RUNPROPERTIES # reload to pick up properties written by writeTDSProperties
   LINKABLEHOSTS=${properties["post.opendap.${server}.linkablehosts"]}
   COPYABLEHOSTS=${properties["post.opendap.${server}.copyablehosts"]}
   OPENDAPHOST=${properties["post.opendap.${server}.opendaphost"]}
   DOWNLOADPREFIX=${properties["post.opendap.${server}.downloadprefix"]}
   CATALOGPREFIX=${properties["post.opendap.${server}.catalogprefix"]}
   OPENDAPBASEDIR=${properties["post.opendap.${server}.opendapbasedir"]}
   OPENDAPINDEX=${properties["post.opendap.${server}.opendapindex"]}
   OPENDAPADDROOT=${properties["post.opendap.addroot"]}
   #
   #--------------------------------------------------------------------
   #  O P E N  D A P    P A T H   F O R M A T I O N
   #--------------------------------------------------------------------
   STORMNAMEPATH=null
   #
   if [[ $BACKGROUNDMET != off ]]; then
      # for NAM, the "advisory number" is actually the cycle time
      YEAR=${properties["forcing.nwp.year"]}
      NWPMODEL=${properties["forcing.nwp.model"]}
      if [ -n "${OPENDAPADDROOT}" ]; then
        STORMNAMEPATH=$OPENDAPADDROOT/$YEAR/$NWPMODEL
      else
        STORMNAMEPATH=$YEAR/$NWPMODEL
      fi
   fi
   if [[ $TROPICALCYCLONE = on ]]; then
      YEAR=${properties["forcing.tropicalcyclone.year"]}
      STORMNAME=${properties["forcing.tropicalcyclone.stormname"]}
      STORMNUMBER=${properties["forcing.tropicalcyclone.stormnumber"]}
      STORMNAMELC=`echo $STORMNAME | tr '[:upper:]' '[:lower:]'`
      basin="al" # FIXME: write/read a property instead of hardcoding the atlantic basin
      if [ -n "${OPENDAPADDROOT}" ]; then
        STORMNAMEPATH=$OPENDAPADDROOT/$YEAR/$basin$STORMNUMBER
        ALTSTORMNAMEPATH=$OPENDAPADDROOT/$YEAR/$STORMNAMELC  # symbolic link with name
      else
        STORMNAMEPATH=$YEAR/$basin$STORMNUMBER
        ALTSTORMNAMEPATH=$YEAR/$STORMNAMELC  # symbolic link with name
      fi
   fi
   if [[ $SCENARIO = "hindcast" ]]; then
      YEAR=${COLDSTARTDATE:0:4}
      if [ -n "${OPENDAPADDROOT}" ]; then
        STORMNAMEPATH=$OPENDAPADDROOT/$YEAR/initialize
      else
        STORMNAMEPATH=$YEAR/initialize
      fi
   fi
   # form path to results on tds based on type of forcing or name of storm
   if [[ $SCENARIO == "asgs.instance.status" ]]; then
      YEAR=${COLDSTARTDATE:0:4}
      if [ -n "${OPENDAPADDROOT}" ]; then
        STORMNAMEPATH=$OPENDAPADDROOT/$YEAR/status
      else
        STORMNAMEPATH=$YEAR/status
      fi
      OPENDAPSUFFIX=$HPCENV/$INSTANCENAME
      # update the url properties in the status json files before posting them
      # and save the url for keeping track of the previous url
      hookStatusURL=$DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/hook.status.json
      asgsInstanceStatusURL=$DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/asgs.instance.status.json
      cp -f hook.status.json tmp.hook.status.json 2>> $SYSLOG
      awk -f $SCRIPTDIR/monitoring/replaceURL.awk -v u=\"$hookStatusURL\" -v i=\"$asgsInstanceStatusURL\" tmp.hook.status.json > hook.status.json 2>>$SYSLOG
      rm tmp.hook.status.json 2>>$SYSLOG
   else
      OPENDAPSUFFIX=$CYCLE/$GRIDNAME/$HPCENV/$INSTANCENAME/$SCENARIO
   fi
   echo "post.opendap.${server}.opendapsuffix : $OPENDAPSUFFIX" >> $RUNPROPERTIES 2>> $SYSLOG
   #
   # Create full path to results for server file sytem.
   # OPENDAPBASEDIR is specified in platforms.sh.
   OPENDAPDIR=$OPENDAPBASEDIR/$STORMNAMEPATH/$OPENDAPSUFFIX
   echo "post.opendap.${server}.opendapdir : $OPENDAPDIR" >> $RUNPROPERTIES 2>> $SYSLOG
   # create the opendap download url for the run.properties file
   downloadURL=$DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX
   # add downloadurl or downloadurl_backup property to run.properties file
   if [[ ! `grep downloadurl $RUNPROPERTIES` =~ downloadurl ]]; then
      echo "downloadurl : $downloadURL" >> $RUNPROPERTIES 2>> ${SYSLOG}
   else
      backupNum=`grep downloadurl $RUNPROPERTIES | wc -l`
      echo "downloadurl_backup$backupNum : $downloadURL" >> $RUNPROPERTIES 2>> ${SYSLOG}
   fi
   #-----------------------------------------------------------------------
   #           D E T E R M I N E   M E T H O D
   #-----------------------------------------------------------------------
   # Establish the default method of posting results for service via opendap
   # The actual method will depend on the configuration in platforms.sh.
   OPENDAPPOSTMETHOD=scp
   #
   # mvb20190620: Testing rsync with the LSU CCR thredds server
   if [[ $server = "lsu_ccr_tds" ]]; then
       OPENDAPPOSTMETHOD=rsync
   fi
   #
   # Determine whether to copy files instead of using scp by looking at the
   # list of HPC machines that share a common filesystem with this TDS.
   for hpc in ${COPYABLEHOSTS[*]}; do
      if [[ $hpc = $HPCENVSHORT ]]; then
         OPENDAPPOSTMETHOD=copy
      fi
   done
   #
   # Determine whether to create symbolic links by looking at the
   # list of HPC machines that share a common filesystem with this TDS.
   # This comes last, so it takes precedence above the others if multiple
   # file delivery mechanisms are possible.
   for hpc in ${LINKABLEHOSTS[*]}; do
      if [[ $hpc = $HPCENVSHORT ]]; then
         OPENDAPPOSTMETHOD=link
      fi
   done
   #
   # If the HPC and TDS do not share a common filesystem, use scp with
   # public key authentication to copy the files to the server hosting THREDDS.
   #
   # jgf20160317: Added status check for posting to opendap so that if
   # there is a failure, the Operator is notified rather than downstream
   # data consumers.
   threddsPostStatus=ok
   echo "post.opendap.${server}.opendappostmethod : $OPENDAPPOSTMETHOD" >> $RUNPROPERTIES 2>> $SYSLOG
   #
   #-------------------------------------------------------------------
   #     C R E A T E    N O T I F I C A T I O N   E M A I L
   #-------------------------------------------------------------------
   #
   runStartTime=${properties["RunStartTime"]}

   # dev NOTE: we should not get crazy here with all of the options of
   # passing metadata via subject; the following does little but gives
   # an indication of the chaos that can ensue if we perpetuate this
   # method - if email subject modification is requested again, be sure
   # bring it up for discussion during team deliberations

   # default primary subject
   subject="ADCIRC POSTED for $runStartTime"

   # modify primary subject
   if [[ "$SCENARIO" == "nowcast" ]]; then
     subject="ADCIRC NOWCAST POSTED for $runStartTime"
   elif [[ "$SCENARIO" == "hindcast" ]]; then
     subject="ADCIRC HINDCAST POSTED for $runStartTime"
   elif [[ "$SCENARIO" == "asgs.instance.status" ]]; then
     subject="ADCIRC STATUS POSTED for $runStartTime"
   fi

   # decorate subject (append or prepend) - so works with any value of primary
   #  "$subject" as it's determined above
   if [[ $TROPICALCYCLONE == "on" ]]; then
      subject="${subject} (TC)"
   fi
   subject="${subject} $SCENARIONUMBER $HPCENV.$INSTANCENAME $_ASGSADMIN_ID"
   echo "post.opendap.${server}.subject : $subject" >> $RUNPROPERTIES 2>> $SYSLOG
   if [ "$OPENDAPINDEX" == "catalog.html" ]; then
     POSTED_LINK=$CATALOGPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/$OPENDAPINDEX
   else
     POSTED_LINK=$DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/$OPENDAPINDEX
   fi
   if [[ "$SCENARIO" == "asgs.instance.status" && -s "asgs.instance.status.json" ]]; then
      logfile=`basename $SYSLOG`
      subject="ADCIRC POSTED status of $HPCENV.$INSTANCENAME"
      echo "post.opendap.${server}.subject : $subject" >> $RUNPROPERTIES 2>> $SYSLOG
cat <<END > ${SCENARIODIR}/opendap_results_notify_${server}.txt

The status of $HPCENV.$INSTANCENAME has been posted to $CATALOGPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/$OPENDAPINDEX

The instance status file is : $DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/asgs.instance.status.json
The hook status file is : $DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/hook.status.json
The log file is : $DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/$logfile

or wget the file with the following commands

wget $DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/asgs.instance.status.json
wget $DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/hook.status.json
wget $DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/$logfile

END

   else
cat <<END > ${SCENARIODIR}/opendap_results_notify_${server}.txt

The results for cycle $CYCLE have been posted to $POSTED_LINK

The run.properties file is : $DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/run.properties

or wget the file with the following command

wget $DOWNLOADPREFIX/$STORMNAMEPATH/$OPENDAPSUFFIX/run.properties
END

   fi
   #
   #-------------------------------------------------------------------
   #                P O S T   V I A   S C P
   #-------------------------------------------------------------------
   # jgf20160803: Changed if/then to case-switch to accommodate new "copy" method.
   case $OPENDAPPOSTMETHOD in
   "scp")
      allMessage "$SCENARIO: $_THIS: Transferring files to $OPENDAPDIR on $OPENDAPHOST."
      retry=0
      mkdirRetryLimit=10 # FIXME: hardcoded for now
      while [[ $retry -lt $mkdirRetryLimit ]]; do
         MSG="($THIS: WAL: remote cmd) ssh $OPENDAPHOST \"mkdir -p $OPENDAPDIR\""
         logMessage "$MSG" $SSHLOGFILE
         unset MSG
         ssh $OPENDAPHOST <<SSHCMD >> $SCENARIOLOG 2>&1
# this block will be executed on the remote server,
# variables are interpolated locally unless escaped
# with a backslash, '\'
mkdir -p "$OPENDAPDIR"
SSHCMD
         if [[ $? != 0 ]]; then
            MSG="$SCENARIO: $_THIS: Failed to create the directory $OPENDAPDIR on the remote machine ${OPENDAPHOST}."
            consoleMessage "${W} $MSG" $SSHLOGFILE
            unset MSG
            threddsPostStatus=fail
         else
            MSG="$SCENARIO: $_THIS: Successfully created the directory $OPENDAPDIR on the remote machine ${OPENDAPHOST}."
            logMessage "$MSG" $SSHLOGFILE
            unset MSG
            break
         fi
         retry=`expr $retry + 1`
         if [[ $retry -lt $mkdirRetryLimit ]]; then
            logMessage "$SCENARIO: $_THIS: Trying again." $SSHLOGFILE
         else
            MSG="$SCENARIO: $_THIS: Maximum number of retries has been reached. Moving on to the next operation."
            logMessage "$MSG" $SSHLOGFILE
            unset MSG
         fi
      done
      # add code to create write permissions on directories so that other
      # Operators can post results to the same directories
      #OPENDAPSUFFIX=$CYCLE/$GRIDNAME/$HPCENV/$INSTANCENAME/$SCENARIO
      partialPath=$OPENDAPDIR
      while [[ $partialPath != $OPENDAPBASEDIR  ]]; do
         retry=0
         while [[ $retry -lt $timeoutRetryLimit ]]; do
            # this operation is expected to fail on the top level directory
            # (the year) on most (but not all) thredds servers, so only need
            # to try this once on the top level directory
            # to avoid filling log files with unhelpful and somewhat
            # alarming error messages
            if [[ `basename $partialPath` == $YEAR || `basename $partialPath` == "nam" ]]; then
                # avoid retrying and associated log messages
                retry=$timeoutRetryLimit
            fi
            MSG="($THIS: WAL: remote cmd) ssh $OPENDAPHOST \"chmod a+wx $partialPath\""
            logMessage "$MSG" $SSHLOGFILE
            unset MSG
            remotePathOwner=$(ssh $OPENDAPHOST "stat -c %u \"$partialPath\"")
            remoteUser=$(ssh $OPENDAPHOST 'id -u $USER') # single quotes to prevent $USER from being expanded locally
            if [[ $remoteUser -eq $remotePathOwner ]]; then
               ssh $OPENDAPHOST bash <<SSHCMD >> $SYSLOG 2>&1
# this block will be executed on the remote server,
# variables are interpolated locally unless escaped
# with a backslash, '\'
  if [ -w $partialPath ]; then
    chmod a+wx "$partialPath"
  fi
SSHCMD
               if [[ $? != 0 ]]; then
                  MSG="$SCENARIO: $_THIS: Failed to change permissions on the directory $partialPath on the remote machine ${OPENDAPHOST}."
                  logMessage "$MSG" $SSHLOGFILE
                  unset MSG
                  threddsPostStatus=fail
               else
                  MSG="$SCENARIO: $_THIS: Successfully changed permissions to a+wx on '$partialPath'."
                  logMessage "$MSG" $SSHLOGFILE
                  unset MSG
                  break
               fi
               retry=`expr $retry + 1`
               if [[ $retry -lt $timeoutRetryLimit ]]; then
                  logMessage "$SCENARIO: $_THIS: Trying again." $SSHLOGFILE
               else
                  MSG="$SCENARIO: $_THIS: Maximum number of retries has been reached. Moving on to the next operation."
                  logMessage "$MSG" $SSHLOGFILE
                  unset MSG
               fi
            else
               break
            fi
         done
         # cut off the end of the partial path and keep going until we get down
         # to OPENDAPBASEDIR
         partialPath=`dirname $partialPath`
      done
      #
      # add a symbolic link for the storm name if this is tropicalcyclone forcing
      if [[ $TROPICALCYCLONE != off ]]; then
         retry=0
         while [[ $retry -lt $timeoutRetryLimit ]]; do
            MSG="($THIS: WAL: remote cmd) ssh $OPENDAPHOST \"ln -s $OPENDAPBASEDIR/$STORMNAMEPATH $OPENDAPBASEDIR/$ALTSTORMNAMEPATH\""
            logMessage "$MSG" $SSHLOGFILE
            unset MSG
            ssh $OPENDAPHOST bash <<SSHCMD >> $SYSLOG 2>&1
# this block will be executed on the remote server,
# variables are interpolated locally unless escaped
# with a backslash, '\'
if [[ -e "$OPENDAPBASEDIR/$STORMNAMEPATH" && ! -e "$OPENDAPBASEDIR/$ALTSTORMNAMEPATH" ]]; then
   ln -s "$OPENDAPBASEDIR/$STORMNAMEPATH" "$OPENDAPBASEDIR/$ALTSTORMNAMEPATH"
fi
SSHCMD
            if [[ $? != 0 ]]; then
               MSG="$SCENARIO: $_THIS: Failed to create symbolic link for the storm name."
               consoleMessage "${W} $MSG" $SSHLOGFILE
               unset MSG
               threddsPostStatus=fail
            else
               logMessage "$SCENARIO: $_THIS: Successfully created symbolic link to storm name." $SSHLOGFILE
               break
            fi
            retry=`expr $retry + 1`
            if [[ $retry -lt $timeoutRetryLimit ]]; then
               logMessage "$SCENARIO: $_THIS: Trying again." $SSHLOGFILE
            else
               MSG="$SCENARIO: $_THIS: Maximum number of retries has been reached. Moving on to the next operation."
               logMessage "$MSG" $SSHLOGFILE
               unset MSG
            fi
         done
      fi
      consoleMessage "${I} $THIS: Processing files (sendEmail? $sendEmail)"
      for file in ${FILES[*]}; do
         MSG="Processing $file (sendEmail? $sendEmail)"
         logMessage "$MSG" $SSHLOGILE
         # send opendap posting notification email early if directed
         if [[ $file == "sendNotification" ]]; then
            if [[ $sendEmail == "yes" ]]; then
               MSG="$SCENARIO: $_THIS: Sending 'results available' email to the following addresses before the full set of results has been posted: $OPENDAPNOTIFY."
               logMessage "$MSG" $SSHLOGFILE
               unset MSG
               # use asgs sendmail if Operator has set it up
               MSG="cat ${SCENARIODIR}/opendap_results_notify_${server}.txt | tee -a ${SCENARIOLOG} | asgs-sendmail --subject \"$subject\" --to \"$OPENDAPNOTIFY\" 2>> ${SCENARIOLOG} 2>&1"
               logMessage "$MSG" $SSHLOGFILE
               unset MSG
               cat ${SCENARIODIR}/opendap_results_notify_${server}.txt | tee -a ${SCENARIOLOG} | asgs-sendmail --subject "$subject" --to "$OPENDAPNOTIFY" 2>> ${SCENARIOLOG} 2>&1
               ERR=$?
               if [[ $ERR != $EXIT_SUCCESS ]]; then
                 MSG="$THIS: Failed to send email to '$OPENDAPNOTIFY'"
                 consoleMessage "${W} $MSG" $SSHLOGFILE
                 unset MSG
                 sendEmail="error"
               else
                 sendEmail="sent"
               fi
               continue
            else
               # we are here because OPENDAPNOTIFY indicates an email should not be sent
               continue # sendNotification is not really a file, so go to the next (actual) file
            fi
         fi

         chmod +r $file 2>> $SCENARIOLOG
         MSG="$SCENARIO: $_THIS: Transferring $file to ${OPENDAPHOST}:${OPENDAPDIR}."
         logMessage "$MSG" $SSHLOGFILE
         unset MSG
         retry=0
         while [[ $retry -lt $timeoutRetryLimit ]]; do
            MSG="($THIS: WAL: remote file xfer) scp $file ${OPENDAPHOST}:${OPENDAPDIR}"
            logMessage "$MSG" $SSHLOGFILE
            unset MSG
            scp $file ${OPENDAPHOST}:${OPENDAPDIR} >> $SCENARIOLOG 2>&1
            if [[ $? != 0 ]]; then
               threddsPostStatus=fail
               MSG="$SCENARIO: $_THIS: Failed to transfer the file $file to ${OPENDAPHOST}:${OPENDAPDIR}."
               consoleMessage "${W} $MSG" $LOGFILE
               unset MSG
            else
               MSG="$SCENARIO: $_THIS: Successfully transferred the file."
               logMessage "$MSG" $SSHLOGFILE
               unset MSG
               break
            fi
            retry=`expr $retry + 1`
            if [[ $retry -lt $timeoutRetryLimit ]]; then
               MSG="$SCENARIO: $_THIS: Trying again."
               consoleMessage "${W} $MSG" $LOGFILE
               unset MSG
            else
               MSG="$SCENARIO: $_THIS: Maximum number of retries has been reached. Moving on to the next operation."
               consoleMessage "${W} $MSG" $SSHLOGFILE
               unset MSG
            fi
         done
         # give the file read permissions on the remote filesystem
         fname=`basename $file`
         retry=0
         while [[ $retry -lt $timeoutRetryLimit ]]; do
            MSG="($THIS: WAL: remote cmd) ssh $OPENDAPHOST \"chmod +r $OPENDAPDIR/$fname\""
            logMessage "$MSG" $SSHLOGFILE
            unset MSG
            ssh $OPENDAPHOST bash <<SSHCMD 2>> $SYSLOG
# this block will be executed on the remote server,
# variables are interpolated locally unless escaped
# with a backslash, '\'
chmod +r "$OPENDAPDIR/$fname"
SSHCMD
            if [[ $? != 0 ]]; then
               threddsPostStatus=fail
               MSG="$SCENARIO: $_THIS: Failed to give the file $fname read permissions in ${OPENDAPHOST}:${OPENDAPDIR}."
               consoleMessage "${W} $MSG" $SSHLOGFILE
               unset MSG
            else
               logMessage "$SCENARIO: $_THIS: Successfully changed permissions to +r on $OPENDAPDIR/$fname." $SSHLOGFILE
               break
            fi
            retry=`expr $retry + 1`
            if [[ $retry -lt $timeoutRetryLimit ]]; then
               MSG="$SCENARIO: $_THIS: Trying again."
               consoleMessage "${W} $MSG" $SSHLOGFILE
            else
               MSG="$SCENARIO: $_THIS: Maximum number of retries has been reached. Moving on to the next operation."
               consoleMessage "${W} $MSG" $SSHLOGFILE
               unset MSG
            fi
         done
      done
      ;;
   #-------------------------------------------------------------------
   #                P O S T   V I A   R S Y N C
   #-------------------------------------------------------------------
   # mvb20190618: Added to support time-out issues with general scp transfers
   "rsync")
      echo "post.opendap.${server}.rsyncsshoptions : $rsyncSSHOptions" >> $RUNPROPERTIES 2>> $SYSLOG
      rsyncOptions="-z --copy-links"
      echo "post.opendap.${server}.rsyncoptions : $rsyncOptions" >> $RUNPROPERTIES 2>> $SYSLOG
      logMessage "$SCENARIO: $_THIS: Transferring files to $OPENDAPDIR on $OPENDAPHOST." $SSHLOGFILE
      ssh $OPENDAPHOST bash <<SSHCMD >> $SCENARIOLOG 2>&1
# this block will be executed on the remote server,
# variables are interpolated locally unless escaped
# with a backslash, '\'
mkdir -p "$OPENDAPDIR"
SSHCMD
      if [[ $? != 0 ]]; then
         MSG="$SCENARIO: $_THIS: Failed to create the directory $OPENDAPDIR on the remote machine $OPENDAPHOST."
         consoleMessage "${W} $MSG" $SSHLOGFILE
         unset MSG
         threddsPostStatus=fail
      fi
      # add code to create write permissions on directories so that other
      # Operators can post results to the same directories
      partialPath=$OPENDAPDIR
      while [[ $partialPath != $OPENDAPBASEDIR  ]]; do
         retry=0
         while [[ $retry -lt $timeoutRetryLimit ]]; do
            logMessage "($THIS: WAL: remote cmd) ssh $OPENDAPHOST \"chmod a+wx $partialPath\"" $RUNDR
            ssh $OPENDAPHOST bash <<SSHCMD >> $SYSLOG 2>&1
# this block will be executed on the remote server,
# variables are interpolated locally unless escaped
# with a backslash, '\'
if [[ -d "$partialPath" && $(stat -c %u "$partialPath") -eq $(id -u $USER) ]]; then
  if [ -w $partialPath ]; then
    chmod a+wx $partialPath
  fi
fi
SSHCMD
            if [[ $? != 0 ]]; then
               MSG="$SCENARIO: $_THIS: Failed to change permissions on the directory $partialPath on the remote machine ${OPENDAPHOST}."
               consoleMessage "${W} $MSG" $SSHLOGFILE
               unset MSG
               threddsPostStatus=fail
            else
               allMessage "$SCENARIO: $_THIS: Successfully changed permissions."
               break
            fi
            retry=`expr $retry + 1`
            if [[ $retry -lt $timeoutRetryLimit ]]; then
               MSG="$SCENARIO: $_THIS: Trying again."
               logMessage "$MSG" $SSHLOGFILE
               unset MSG
            else
               MSG="$SCENARIO: $_THIS: Maximum number of retries has been reached. Moving on to the next operation."
               logMessage "$MSG" $SSHLOGFILE
               unset MSG
            fi
         done
         # cut off the end of the partial path and keep going until we get down
         # to OPENDAPBASEDIR
         partialPath=`dirname $partialPath`
      done
      for file in ${FILES[*]}; do
         echo "Processing $file (sendEmail? $sendEmail)"
         # send opendap posting notification email early if directed
         if [[ $file = "sendNotification"  && $OPENDAPNOTIFY != "null" && $OPENDAPNOTIFY != "" ]]; then
            allMessage "$SCENARIO: $_THIS: Sending 'results available' email to the following addresses before the full set of results has been posted: $OPENDAPNOTIFY."
            echo "$SCENARIO: $_THIS: Sending 'results available' email to the following addresses before the full set of results has been posted: $OPENDAPNOTIFY."
            cat ${SCENARIODIR}/opendap_results_notify_${server}.txt | asgs-sendmail  --subject "$subject" --to "$OPENDAPNOTIFY" 2>> ${SYSLOG} 2>&1
            ERR=$?
            if [[ $ERR != $EXIT_SUCCESS ]]; then
              MSG="$THIS: Failed to send email to '$OPENDAPNOTIFY'"
              consoleMessage "${W} $MSG" $SSHLOGFILE
              unset MSG
            else
              opendapEmailSent=yes
            fi
            continue
         fi
         chmod +r "$file" 2>> $SYSLOG
         MSG="$SCENARIO: $_THIS: Transferring $file to ${OPENDAPHOST}:${OPENDAPDIR}."
         consoleMessage "${I} $MSG" $SSHLOGFILE
         rsync ${rsyncOptions} ./${file} ${OPENDAPHOST}:${OPENDAPDIR} >> $SCENARIOLOG 2>&1
         if [[ $? != 0 ]]; then
            threddsPostStatus=fail
            MSG="$SCENARIO: $_THIS: Failed to transfer the file $file to ${OPENDAPHOST}:${OPENDAPDIR}."
            consoleMessage "${W} $MSG" $SSHLOGFILE
            unset MSG
         fi
      done
      ;;
   *)
      threddsPostStatus=fail
      MSG="$SCENARIO: $_THIS: The opendap post method $OPENDAPPOSTMETHOD was not recognized."
      consoleMessage "$MSG"
      unset MSG
      ;;
   esac # end case of transport methods (scp, rsync, etc)

   #
   #-------------------------------------------------------------------
   #      S E N D   N O T I F I C A T I O N   E M A I L
   #-------------------------------------------------------------------
   #

   if [[ $sendEmail == "yes" ]]; then
      MSG="$SCENARIO: $_THIS: Sending 'results available' email to the following addresses: $OPENDAPNOTIFY."
      logMessage "$MSG" $SSHLOGFILE
      unset MSG
      # use asgs sendmail if Operator has set it up
      cat ${SCENARIODIR}/opendap_results_notify_${server}.txt | asgs-sendmail --subject "$subject" "$OPENDAPNOTIFY" 2>> ${SYSLOG} 2>&1
      ERR=$?
      if [[ $ERR != $EXIT_SUCCESS ]]; then
        MSG="$_THIS: Failed to send email to '$OPENDAPNOTIFY'"
        consoleMessage "${W} $MSG" $SSHLOGFILE
        unset MSG
        sendEmail="error"
      else
        sendEmail="sent"
      fi
   fi

   # reset for next server (if there are more)
   sendEmail=$sendEmail_orig
done # end loop over opendap servers
