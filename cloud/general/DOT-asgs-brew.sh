#!/usr/bin/env bash
# xxx THIS FILE IS GENERATED BY asgs-brew.pl                                           xxx
# xxx DO NOT CUSTOMIZE THIS FILE, IT WILL BE OVERWRITTEN NEXT TIME asgs-brew.pl IS RUN xxx

# This file is part of the ADCIRC Surge Guidance System (ASGS).
#
# The ASGS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ASGS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with the ASGS.  If not, see <http://www.gnu.org/licenses/>.
#----------------------------------------------------------------

# Developer Note:
# This must remain consistent with what's exported by asgs-brew.pl, and
# vice versa; if something is added in define(), be sure to add the
# corresponding entry in show() - including usage
#
# Also note, any function that can be encapsulated as a separate shell
# script # is located in $SCRIPTDIR/bin; if a command is presented as a
# bash # function here, it is because it affects the environment. This
# impact can't be offloaded to the child process that is invoked when
# running external scripts.

BK=$(tput setaf 0)
RD=$(tput setaf 1)
GR=$(tput setaf 2)
YW=$(tput setaf 3)
BL=$(tput setaf 4)
MG=$(tput setaf 5)
CY=$(tput setaf 6)
WH=$(tput setaf 6)
R=$(tput sgr0)
B=$(tput bold)

export I="(${CY}info${R})"
export W="(${B}${RD}!! warning${R})"

asgsh() {  # disable
  echo "The nesting of \"asgsh\" inside of asgsh (you're in it now, pid: $_ASGSH_PID) is not allowed."
}

help() {
  echo Command Line Options \(used when invoking asgsh from login shell\):
  echo "   -A \"command to run..\" - run a command in asgsh, then quit"
  echo "   -d                      - debug mode, turns on 'set -x'"
  echo "   -h                      - displays available asgsh command line flags, then exits"
  echo "   -p  profile             - launches the ASGS Shell environment and immediate loads specified profile on start, if it exists"
  echo "   -v                      - run 'verify' command, then exist shell"
  echo "   -x                      - skips loading of platforms.sh and properties.sh (could become default)"
  echo
  echo ASGS Shell Commands:
  echo "   build   adcirc          - interactive tool for building and local registering versions of ADCIRC for use with ASGS"
  echo "           jq              - optionally installs “jq”, which is an awk like utility but for JSON data"
  echo "           replaycli       - optionally installs Perl script that interacts with StormReplay.com service"
  echo "   backup  <FILE.tgz>      - saves all files not in the ASGS GIT repository, includes all binary (compiled) artifiacts"
  echo "           <HOST:FILE.tgz> - ... sends backup TGZ to a remote host via ssh; use the 'restore' command fetch and unpack this TGZ"
  echo "   clone   profile         - launches guided process for cloning the current profile, including copying the configuratin file"
  echo "   define  config          - defines ASGS configuration file used by 'run', (\$ASGS_CONFIG). 'define' replaces old 'set' command"
  echo "           editor          - defines default editor, (\$EDITOR)"
  echo "           scratch         - defines ASGS main script directory used by all underlying scripts, (\$SCRATCH)"
  echo "           scriptdir       - defines ASGS main script directory used by all underlying scripts, (\$SCRIPTDIR)"
  echo "           workdir         - defines ASGS main script directory used by all underlying scripts, (\$WORK)"
  echo "   DELETE                  - foricibly removes all files in \$SCRIPTDIR that is not presently in the git repository"
  echo "   delete  profile <NAME>  - deletes named profile"
  echo "           adcirc  <NAME>  - deletes named ADCIRC profile"
  echo "           config          - deletes configuration file for current profile, unsets 'config' var. Interactively confirms"
  echo "           statefile       - deletes the state file associated with a profile, effectively for restarting from the initial advisory"
  echo "   dump    <param>         - dumps (using cat) contents specified files: config, exported (variables); and if defined: statefile, syslog"
  echo "   edit    <thing>         - adcirc <NAME>, asgs-global, asgsh-profile, config, jobs, mail-log, meshes, platforms, profile, statefile, syslog"
  echo "   fetch   <thing>         - tool for fetching supported external resources, e.g., git repos; 'fetch' with no parameter will list what is supported"
  echo "   goto|g  <param>         - change CWD to a supported directory. Type 'goto options' to see the currently supported options"
  echo "   guess   platform        - attempts to guess the current platform as supported by platforms.sh (e.g., frontera, supermic, etc)"
  echo "   init    config          - wizard for creating a starting point for a profile's configuration file"
  echo "           keys            - wrapper around ssh-keygen that offers to send the public key to someone via asgs-sendmail"
  echo "   inspect <option>        - alias to 'edit' for better semantics; e.g., 'inspect syslog' or 'inspect statefile'"
  echo "   list    <param>         - lists different things, please see the following options; type 'list options' to see currently supported options"
  echo "   load    profile <NAME>  - loads a saved profile by name; use 'list profiles' to see what's available"
  echo "           adcirc  <NAME>  - loads information a version of ADCIRC into the current environment. Use 'list adcirc' to see what's available"
  echo "   move    statefile       - moves statefile out of the way, safer and more future friendly than delete"
  echo "   purge   <param>         - deletes specified file or directory"
  echo "           rundir          - deletes run directory associated with a profile, useful for cleaning up old runs and starting over for the storm"
  echo "   rebuild profile         - wizard for recreating an ASGS profile using an existing configuration file"
  echo "   restore <FILE.tgz>      - fetchs and restores files contained in 'FILE.tgz'" 
  echo "           <HOST:FILE.tgz> - ... fetches backup TGZ from a remote host via ssh; 'backup' command creates and sends TGZ to specified location"
  echo "   rl                      - reload current profile, equivalent to 'load profile <current-profile-name>'"
  echo "   run                     - runs asgs using config file, requires that \$ASGS_CONFIG is set; most handy after 'load'ing a profile"
  echo "   save    profile <NAME>  - saves an asgs named profile, '<NAME>' not required if a profile is loaded"
  echo "   show    <param>         - shows specified profile variables, to see current list type 'show help'"
  echo "           exported        - dumps all exported variables and provides a summary of what asgsh tracks"
  echo "   sq                      - shortcut for \"squeue -u \$USER\" (if squeue is available)"
  echo "   switch  <option>        - alias to 'load' for better semantics; e.g., 'switch profile next-profile'"
  echo "   tailf   syslog          - executes 'tail -f' on ASGS instance's system log"
  echo "   verify  [<option>]      - verfies the ASGSH installation"
  echo "           adcirc          - (alias: va) verifies ADCIRC, if available"
  echo "           email <EM@IL>   - (alias: ve) verifies email configuration is correct, will test send email if provided an address"
  echo "           regressions     - (alias: vr) runs regression test suite for previously solved issues"
  echo "           perl            - (alias: vp) verifies the Perl environment and modules"
  echo "           ssh_config      - checks \$HOME/.ssh/config is set up properly"
  echo "   exit                    - exits ASGS shell, returns \$USER to login shell"
}

_is_a_num()
{
  re='[1-9][0-9]?$'
  if [[ "${1}" =~ $re ]] ; then
    echo -n $1
  else
    echo -n -1
  fi
  return
}

_pwd() {
  echo "${I} current directory: $(pwd)"
}

# change to a directory know by asgsh
goto() {
  case "${1}" in
  adcircworkdir)
    if [ -e "$ADCIRCDIR/work" ]; then
      cd $ADCIRCDIR/work
      _pwd
    else
      echo "ADCIRCDIR not yet defined"
    fi
    ;;
  adcircdir)
    if [ -e "$ADCIRCDIR" ]; then
      cd $ADCIRCDIR
      _pwd
    else
      echo "ADCIRCDIR not yet defined"
    fi
    ;;
  configdir)
    if [ -n "$ASGS_CONFIG" ]; then
       cd $(dirname "$ASGS_CONFIG")
      _pwd
    else
      echo "ASGS_CONFIG not yet defined"
    fi
    ;;
  installdir)
    if [ -e "$ASGS_INSTALL_PATH" ]; then
      cd $ASGS_INSTALL_PATH
      _pwd
    else
      echo "ASGS_INSTALL_PATH not defined, which is concerning. Did you complete the installation of ASGS?"
    fi
    ;;
  lastsubdir)
    if [ -e "$LASTSUBDIR" ]; then
      cd $LASTSUBDIR
      _pwd
    else
      echo "LASTSUBDIR not yet defined"
    fi
    ;;
  rundir)
    if [ -e "$RUNDIR" ]; then
      cd $RUNDIR
      _pwd
    else
      echo "RUNDIR not yet defined"
    fi
    ;;
  scratchdir)
    if [ -e "$SCRATCH" ]; then
      cd $SCRATCH
      _pwd
    else
      echo "SCRATCH not yet defined"
    fi
    ;;
  scriptdir)
    if [ "$SCRIPTDIR" ]; then
      cd $SCRIPTDIR
      _pwd
    else
      echo "scriptdir not yet defined"
    fi
    ;;
  workdir)
    if [ "$WORK" ]; then
      cd $WORK
      _pwd
    else
      echo "workdir not yet defined"
    fi
    ;;
  *)
    if [ -d "${1}" ]; then
      cd "${1}"
      _pwd
    else
      echo 'Only "adcircdir", "configdir", "rundir", "scratchdir", "scriptdir", and "workdir" are supported at this time.'
    fi
    ;;
  esac
}

# dump envars needed to establish the environment to use the specified
# version of ADCIRC 
export_adcirc() {
  trap 'echo && exit 1' SIGINT
  local adcirc_profile_name=${1:-$ADCIRC_PROFILE_NAME}
  if [[ -n "$adcirc_profile_name" && -e "$ADCIRC_META_DIR/$adcirc_profile_name" ]]; then
    source $ADCIRC_META_DIR/$adcirc_profile_name
    cat <<EOENV
## copy n' paste this entire BLOCK anywhere ADCIRC must be accessed

#-- BEGIN ADCIRC Live (C) 2024-present exported environment
export PATH=$ADCIRCDIR:\$PATH
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:\$LD_LIBRARY_PATH
export LD_INCLUDE_PATH=$LD_INCLUDE_PATH:\$LD_INCLUDE_PATH
## For commercial support options, email help@support.adcirc.live
## or visit https://adcirc.live for more information
# Copyright(C) 2024-present Brett Estrade <brett.estrade@adcirc.live>
# Copyright(C) 2024-present Jason Fleming <jason.fleming@adcirc.live>
#-- END ADCIRC Live (C) 2024-present exported environment 
EOENV
  else
    echo "It appears as if ADCIRC must be loaded first. You may email help@support.adcirc.live for assistance."
  fi
}

# load environment related things like an ADCIRC environment or saved ASGS environment
load() {
  trap 'echo && exit 1' SIGINT
  CHOICES=();
  case "${1}" in
    adcirc)
      if [ -z "${2}" ]; then
        for i in $(list adcirc | awk '{print $2}'); do
          CHOICES+=("$i")
        done
        C=${#CHOICES[@]}
        if [ $C -eq 0 ]; then
          echo "No versions of ADCIRC are available. Run 'build adcirc' to install one."
          return
        elif [ $C -eq 1 ]; then
          __ADCIRC_BUILD=$(list adcirc | awk '{print $2}')
        elif [ $C -gt 1 ]; then
          list adcirc
          read -p "Choose a number (1-$C) or name from above: " _SELECTION
          _isnum=$(_is_a_num $_SELECTION)
          if [[ $_isnum -gt -1 && $_isnum -le $C ]]; then
            __ADCIRC_BUILD=${CHOICES[$(($_isnum-1))]}
          elif [ -n "$_SELECTION" ]; then
            __ADCIRC_BUILD=$_SELECTION
          else
            echo "A valid selection must be made to proceed."
            return
          fi
        fi
      else
        __ADCIRC_BUILD=${2}
      fi
      echo "${I} loading ADCIRC build, '$__ADCIRC_BUILD'."
      if [ -e "${ADCIRC_META_DIR}/${__ADCIRC_BUILD}" ]; then
          # source it
          . ${ADCIRC_META_DIR}/${__ADCIRC_BUILD}
          echo "${I} prepending ADCIRCDIR and SWANDIR to PATH"
          echo "${I}   + $ADCIRCDIR"
          echo "${I}   + $SWANDIR"
          PATH=${SWANDIR}:${ADCIRCDIR}:${PATH}
          export PATH
          save profile ${_ASGSH_CURRENT_PROFILE}
      else
          echo "ADCIRC build, '$__ADCIRC_BUILD' does not exist. Use 'list adcirc' to see a which ADCIRCs are available to load"
      fi
      ;;
    profile)
      if [ -z "${2}" ]; then
        for i in $(list profiles | awk '{print $2}'); do
          CHOICES+=("$i")
        done
        C=${#CHOICES[@]}
        if [ $C -eq 1 ]; then
          NAME=$(list profiles | awk '{print $2}')
        elif [ $C -gt 1 ]; then
          list profiles
          read -p "Choose a number (1-$C) or name from above: " _SELECTION
          _isnum=$(_is_a_num $_SELECTION)
          if [[ $_isnum -gt -1 && $_isnum -le $C ]]; then
            NAME=${CHOICES[$(($_isnum-1))]}
          elif [ -n "$_SELECTION" ]; then
            NAME=$_SELECTION
          else
            echo "${W} A valid selection must be made to proceed."
	    echo
            return
          fi
	  echo
        fi
      else
        NAME=${2}
      fi
      if [ -e "$ASGS_META_DIR/$NAME" ]; then
        export _ASGSH_CURRENT_PROFILE="$NAME"
        _reset_ephemeral_envars
       source "$ASGS_META_DIR/$NAME"
        if [ -n "$_asgsh_splash" ]; then
          echo "${I} loaded '$NAME' into current profile"
        fi
        if [ -e "$ASGS_CONFIG" ]; then
          # extracts info such as 'instancename' so we can derive the location of
          # the state file, then the log file path and actual run directory
          _parse_config $ASGS_CONFIG
        fi
      else
        echo "${W} ASGS profile, '$NAME' does not exist. Use 'list profiles' to see a which profile are available to load"
      fi
      ;;
    *)
      echo "${W} 'load' requires 2 parameters: 'adcirc' or 'profile' as the first; the second parameter defines what to load."
      return
  esac
}

# alias for load, so one may more naturally "switch" profiles
switch() {
  load $@
}

# used to reset ephemeral variables - those created via _parse_config and
# those sourced via _load_state_file (currently hard coded list based on
# what is currently available via STATEFILE
_reset_ephemeral_envars() {
  export INSTANCENAME=
  export STATEFILE=
  export RUNDIR=
  export LASTSUBDIR=
  export SYSLOG=
  export ASGS_CONFIG=
}

# used to unset variables stored in statefile when
# the statefile is not found or is moved or deleted
_unset_statevars() {
  unset STATEFILE
  unset RUNDIR
  unset LASTSUBDIR
  unset SYSLOG
  unset ADVISORY
}

_parse_config() {
  if [ ! -e "${1}" ]; then
    echo "${W} config file is defined, but the file '${1}' does not exist!"
    return
  fi
  # pull out var info the old fashion way...
  export INSTANCENAME=$(egrep '^ *INSTANCENAME=' "${1}" | sed 's/^ *INSTANCENAME=//' | sed 's/ *#.*$//g' | sed -e 's/[^A-Za-z0-9._-]/_/g')
  echo "${I} config file found, instance name is '$INSTANCENAME'"
  echo
  export STATEFILE="$SCRATCH/${INSTANCENAME}.state"
  _load_state_file $STATEFILE
}

_load_state_file() {
  if [ -e "${1}" ]; then
    STATEFILE=${1}
    # pull out var info the old fashioned way...
    stateScriptDir=$(egrep '^ *SCRIPTDIR=' "${1}" | sed 's/^ *SCRIPTDIR=//' | sed 's/ *#.*$//g')
    if [[ $SCRIPTDIR != $stateScriptDir ]]; then
      echo "${W} The state file '${1}' exists but has a different SCRIPTDIR than this ASGS installation."
      echo
      echo "${W} '${1}' was not loaded and cannot be used with this ASGS instance."
      echo
      _unset_statevars
      return
    else
      . $STATEFILE
    fi
  else
    echo "${W} state file '${1}' does not exist."
    echo
    echo "${I} no indication of first run yet?"
    echo
    _unset_statevars
  fi

  if [ -d "$RUNDIR" ]; then
    PROPERTIESFILE="$RUNDIR/run.properties"
    if [ -e "$PROPERTIESFILE" ]; then
      echo "... found 'run.properties' file, at '$PROPERTIESFILE'"
    fi
  fi
  return
}

# saves environment as a file named what is passed to the command, gets the
# list of environmental variables to save from $_ASGS_EXPORTED_VARS
save() {
  case "${1}" in
    profile)
      DO_RELOAD=1
      NAME=${2:-$_ASGSH_CURRENT_PROFILE}
      DO_RELOAD=0

      if [ ! -d "$ASGS_META_DIR" ]; then
        mkdir -p "$ASGS_META_DIR"
      fi

      if [ -e "$ASGS_META_DIR" ]; then
        IS_UPDATE=1
      fi
    ;;
    *)
      echo "'save' requires 2 parameters: 'profile' as the first; the second is the profile name."
      return
    return
  esac

  # generates saved profile as a basic shell resource file that simply
  # includes an 'export' line for each variable asgsh cares about; this
  # is defined as part of the shell installation by asgs-brew.pl
  for e in $_ASGS_EXPORTED_VARS; do
    echo "export ${e}=\"${!e}\""      >> "$ASGS_META_DIR/${NAME}.$$.tmp"
  done
  mv "$ASGS_META_DIR/${NAME}.$$.tmp" "$ASGS_META_DIR/${NAME}"

  # print different message based on whether or not the profile already exists
  if [ -n "$IS_UPDATE" ]; then
    echo "${I} profile '$NAME' was updated"
  else
    echo "${I} profile '$NAME' was written"
  fi

  # update prompt so that it's easy to tell at first glance what's loaded
  export _ASGSH_CURRENT_PROFILE=$NAME

  if [ 1 -eq "$DO_RELOAD" ]; then
    load profile $_ASGSH_CURRENT_PROFILE
  fi
}

rebuild() {
  case "${1}" in
    profile)
      _config=${2}
      _default_base_profile=${_ASGSH_CURRENT_PROFILE:-default}
      read -p "Base profile [$_default_base_profile]? " _base_profile
      if [ -z "$_base_profile" ]; then
        _base_profile=$_default_base_profile
      fi
      echo

      load profile $_base_profile

      if [ -z "$_config" ]; then
        read -e -p "Path to ASGS configuration file: " _config
      fi
      if [[ -z "$_config" || ! -e "$_config" ]]; then
        echo "'rebuild profile' requires an existing ASGS configuration file."
        return
      fi
      echo
      ABS_PATH=$(readlink -f "$_config")
      export ASGS_CONFIG=$ABS_PATH
      _parse_config $ASGS_CONFIG

      # default is $INSTANCENAME, grabbed from _parse_config when $ASGS_CONFIG
      # is parsed above
      read -p "New profile name [$INSTANCENAME]? " _profile_name
      if [ -z "$_profile_name" ]; then
        _profile_name=$INSTANCENAME
      fi
      echo

      save profile $_profile_name
      ;;
    *) echo "'clone' only applies to 'profile'"
      ;;
  esac
}

clone() {
  case "${1}" in
    profile)
      if [[ -z "$ASGS_CONFIG" || ! -e "$ASGS_CONFIG" ]]; then
        echo "'clone profile' only proceeds if the parent profile's config file has been defined."
        echo "type, 'save profile <new-profile-name>' if you don't wish to define a config file first."
        return
      fi
      _epoch=$(date +%s)
      _default_new_profile=${_ASGSH_CURRENT_PROFILE}-${_epoch}-clone
      read -p "Name of new profile? [$_default_new_profile] " new_profile_name
      if [ -z "$new_profile_name" ]; then
        new_profile_name=$_default_new_profile
      fi
      _default_new_config=$(dirname $ASGS_CONFIG)/${new_profile_name}.sh
      read -p "Name of new config file? [$_default_new_config] " new_config
      if [ -z "$new_config" ]; then
        new_config=$_default_new_config
      fi
      read -p "Create new profile? [y] " create
      if [[ -z "$create" || "$create" = "y"  ]]; then
        local DIR=$(dirname "${new_config}")
        if [[ ! -d "$DIR" ]]; then
          echo "${W} The directory, '$DIR', does not exist! Create this directory and start again."
          return
        fi
        cp -v $ASGS_CONFIG $new_config
        save profile $new_profile_name
        define config $new_config
        rl
        read -p "Would you like to edit the new configuration file? [y] " _edit
        if [[ -z "$_edit" || "$_edit" = "y" ]]; then
          edit config
        fi
      else
        echo "Profile cloning operation has been aborted."
      fi
      ;;
    *) echo "'clone' only applies to 'profile'"
      ;;
  esac
}

init_config() {
  local PNAME=
  read -p "What would you like use as the base name for the profile? " PNAME
  echo

  local ASGSADMIN=
  read -p "What's your email address, used for diagnostic messages and notifications? " ASGSADMIN
  echo

  local ASGSADMIN_ID=
  read -p "Your initials (or some unique personal identifier) [${USER}$$]? " ASGSADMIN_ID
  if [[ -z "$ASGSADMIN_ID" ]]; then
    ASGSADMIN_ID=$ASGSADMIN
  fi
  echo

  # mesh selection
  local MESHES=()
  local LISTNUM=1
  for m in $(cat $ASGS_MESH_DEFAULTS | grep '")' | sed 's/[")]//g' | awk '{print $1}'); do
    printf "% 2d. %s\n" $LISTNUM $m
    LISTNUM=$(($LISTNUM+1))
    MESHES+=($m)
  done
  # list locally defined meshes if they exist
  local LOCAL_MESH_DEFAULTS="${ASGS_LOCAL_DIR}/config/mesh_defaults.sh"
  if [[ -n "$ASGS_LOCAL_DIR" && -e "$LOCAL_MESH_DEFAULTS" ]]; then
    for m in $(cat $LOCAL_MESH_DEFAULTS | grep '")' | sed 's/[")]//g' | awk '{print $1}'); do
      printf "% 2d. %s (** locally defined)\n" $LISTNUM $m
      LISTNUM=$(($LISTNUM+1))
      MESHES+=($m)
    done
  fi
  printf "% 2d. %s\n" $LISTNUM "custom (edit configuration file after)" 
  OTHERNUM=$(($LISTNUM))
  MESHES+=(custom)
  local select=
  read -p "Select mesh to use [$OTHERNUM]? " select
  if [[ -z "$select" ]]; then
    select=$OTHERNUM
  fi
  select=$(($select-1))
  if [ -z "${MESHES[$select]}" ]; then
    select=$OTHERNUM
  fi
  local GRIDNAME=$(echo ${MESHES[$select]} | awk -F '|' '{print $1}')
  echo
  echo "'$GRIDNAME' has been selected ..."
  echo

  local STORM=99
  local YEAR=$(date +%Y)
  local FORCINGKIND=BACKGROUNDMET
  local FORCING=
  cat<<EOF
Initial forcing to use:

1. Current GFS  (BACKGROUNDMET=GFS)
2. Current NAM  (BACKGROUNDMET=on)
3. NHC Forecast (TROPICALCYCLONE=on)

EOF

read -p "Please choose (1-3) [1]? " FORCING
  if [[ -z "$FORCING" || "$FORCING" == 1 ]]; then
    BACKGROUNDMET=GFS
    TROPICALCYCLONE=off
  elif [[ "$FORCING" == 2 ]]; then
    BACKGROUNDMET=on
    TROPICALCYCLONE=off
  elif [[ "$FORCING" == 3 ]]; then
    BACKGROUNDMET=off
    TROPICALCYCLONE=on
    FORCINGKIND=TROPICALCYCLONE
  else
    echo "${W} Option '$FORCING' is not recognized, defaulting to 1"
    BACKGROUNDMET=GFS
    TROPICALCYCLONE=off
  fi
  echo

  local NCPU=
  read -p "How many total number of CPUs are you planning to run [3]? " NCPU
  if [ -z "$NCPU" ]; then
    NCPU=3
  fi
  echo

  local COLDSTARTDATE=
  local _COLDSTARTDATE=$(get-coldstart-date)
  read -p "Set COLDSTARTDATE [$_COLDSTARTDATE]? " COLDSTARTDATE
  if [[ -z "$COLDSTARTDATE" ]]; then
    COLDSTARTDATE=$_COLDSTARTDATE 
  fi
  echo

  local _INSTANCENAME=
  local INSTANCENAME=${PNAME}_${GRIDNAME}_${ASGSADMIN_ID}
  read -p "Use 'INSTANCENAME' [$INSTANCENAME]? " _INSTANCENAME
  if [ -n "$_INSTANCENAME" ]; then
    INSTANCENAME=$_INSTANCENAME
  fi
  echo

  local SAVEDIR=
  local _SAVEDIR=./
  read -e -p "Directory to save in [$_SAVEDIR]? " SAVEDIR
  if [ -z "$SAVEDIR" ]; then
    SAVEDIR=$_SAVEDIR
  fi
  SAVEDIR=$(echo "$SAVEDIR/" | sed 's/\/\//\//g')
  echo

  local SAVEAS=
  local _SAVEAS=asgs_config_${PNAME}_${ASGSADMIN_ID}.sh

  read -p "Save file as $SAVEDIR[$_SAVEAS]? " SAVEAS
  if [ -z "$SAVEAS" ]; then
    SAVEAS=$_SAVEAS
  fi
  SAVEAS="${SAVEDIR}${SAVEAS}"
  echo

  if [ -e "$SAVEAS" ]; then
    read -p "${W} exists! Proceed [y/N]? " proceed
    echo
    if [[ -z "$proceed" || "$proceed" == "N" || "$proceed" == "n" ]]; then
      echo ${W} no configuration file written ...
      exit 1
    fi
  fi

  # dup out config
cat <<EOCONFIG > $SAVEAS
#!/bin/sh
#
#      Initially generated by the ASGS Configuration File Wizard in asgsh      #
#
#-------------------------------------------------------------------------------
# config.sh: This file is read at the beginning of the execution of the ASGS to
# set up the runs  that follow. It is reread at the beginning of every cycle,
# every time it polls the datasource for a new advisory. This gives the user
# the opportunity to edit this file mid-storm to change config parameters
# (e.g., the name of the queue to submit to, the addresses on the mailing list,
# etc)
#-------------------------------------------------------------------------------

# Fundamental
INSTANCENAME=$INSTANCENAME
GRIDNAME=$GRIDNAME
ASGSADMIN=$ASGSADMIN
ASGSADMIN_ID=$ASGSADMIN_ID

# Input files and templates
source $SCRIPTDIR/config/mesh_defaults.sh

TIDEFAC=on
HINDCASTLENGTH=20.0
BACKGROUNDMET=$BACKGROUNDMET # on | off | GFS
  FORECASTCYCLE="06,18"      # options - "00,06,12,18" (time in "Z", which is UTC/GMT)
TROPICALCYCLONE=$TROPICALCYCLONE
  STORM=$STORM  # only used if TROPICALCYCLONE=on
  YEAR=$YEAR    # only used if TROPICALCYCLONE=on
TRIGGER=rssembedded # required mode
WAVES=off
  REINITIALIZEDSWANT=no # only used if WAVES=on
VARFLUX=off
CYCLETIMELIMIT="99:00:00"

# Computational Resources (related defaults set in platforms.sh)
NCPU=$NCPU
NCPUCAPACITY=9999 # larger limit of total number of CPUs to be using across all jobs
NUMWRITERS=1

# Post processing and publication
EMAILNOTIFY=yes
INTENDEDAUDIENCE="general" #| "developers-only" | "professional"
OPENDAPPOST=opendap_post2.sh
POSTPROCESS=( createMaxCSV.sh includeWind10m.sh createOPeNDAPFileList.sh \$OPENDAPPOST )
hooksScripts[FINISH_SPINUP_SCENARIO]=" output/createOPeNDAPFileList.sh output/\$OPENDAPPOST "
hooksScripts[FINISH_NOWCAST_SCENARIO]=" output/createOPeNDAPFileList.sh output/\$OPENDAPPOST "
TDS=()

# Monitoring
OPENDAPNOTIFY="\$ASGSADMIN"
NOTIFY_SCRIPT=null_notify.sh
# JSON based updates
enablePostStatus="no"
enableStatusNotify="no"
statusNotify="null"


# Initial state (overridden by STATEFILE after ASGS gets going)
COLDSTARTDATE=$COLDSTARTDATE
HOTORCOLD=coldstart
LASTSUBDIR=null
#
# Scenario package
#
PERCENT=default
SCENARIOPACKAGESIZE=2
case \$si in
   -2)
       ENSTORM=hindcast
       ;;
   -1)
       # do nothing ... this is not a forecast
       ENSTORM=nowcast
       ;;
EOCONFIG

if [ "$FORCINGKIND" == "BACKGROUNDMET" ]; then
  cat <<EOCONFIG >> $SAVEAS
    0)
       ENSTORM=namforecastWind10m
       ;;
EOCONFIG
else
  cat <<EOCONFIG >> $SAVEAS
    0)
       ENSTORM=nhcConsensusWind10m
       ;;
EOCONFIG
fi
if [ "$FORCINGKIND" == "BACKGROUNDMET" ]; then
cat <<EOCONFIG >> $SAVEAS
    1)
       ENSTORM=namforecast
       ;;
EOCONFIG
else
cat <<EOCONFIG >> $SAVEAS
    1)
       ENSTORM=nhcConsensus
       ;;
EOCONFIG
fi
cat <<EOCONFIG >> $SAVEAS
    *)
       echo "CONFIGRATION ERROR: Unknown ensemble member number: '\$si'."
      ;;
esac
source $SCRIPTDIR/config/io_defaults.sh # sets met-only mode based on "Wind10m" suffix
PREPPEDARCHIVE=prepped_\${GRIDNAME}_\${INSTANCENAME}_\${NCPU}.tar.gz
HINDCASTARCHIVE=prepped_\${GRIDNAME}_hc_\${INSTANCENAME}_\${NCPU}.tar.gz

# Common 'non-standard' configuration variables to define
# check ~/.asgsh_profile for setting of "ACCOUNT"
#QUEUENAME=normal  # best in ~/.asgsh_profile (may need to create)
#SERQUEUE=normal   # best in ~/.asgsh_profile
#postAdditionalFiles=( /path/to/file1.ext /path/to/file2.ext )         # additional files to POST
#OPENDAPADDROOT=alt-root                                               # prepend alternate root for this set of runs
EOCONFIG

  local doRebuild=
  read -p "Would you like to build a profile based on '$SAVEAS' [Y/n]? " doRebuild
  echo
  if [[ -z "$doRebuild" || "$doRebuild" == "Y" ]]; then
    rebuild profile $SAVEAS
  else
    echo "The configuration file has been saved at '$SAVEAS'"
    echo
  fi
}

init() {
  case "${1}" in
    config)
      shift
      init_config $@ 
      ;;
    keys)
      shift
      init-keys $@
      ;;
   *)
      echo "${W} '${1}' is not supported by 'init'"
      ;;
  esac
}

# reload current profile
rl() {
  load profile $_ASGSH_CURRENT_PROFILE
}

# defines the value of various important environmental variables,
# exports them to current session (and are available to be saved)
define() {
  if [ -z "${2}" ]; then
    echo "'define' requires 2 arguments - parameter name and value"
    return
  fi
  _DEFINE_OK=1
  case "${1}" in
    adcircdir)
      export ADCIRCDIR=${2}
      echo "${I} ADCIRCDIR is defined as '${ADCIRCDIR}'"
      ;;
    adcircbranch)
      export ADCIRC_GIT_BRANCH=${2}
      echo "${I} ADCIRC_GIT_BRANCH is defined as '${ADCIRC_GIT_BRANCH}'"
      ;;
    adcircremote)
      export ADCIRC_GIT_REMOTE=${2}
      echo "${I} ADCIRC_GIT_REMOTE is defined as '${ADCIRC_GIT_REMOTE}'"
      ;;
    config)
      # converts relative path to absolute path so the file is available regardless of the `pwd`
      ABS_PATH=$(readlink -f "${2}")
      # makes sure that file exists, will not 'define config' if the file does not
      if [ ! -e "$ABS_PATH" ]; then
        echo "'${ABS_PATH}' does not exist! 'define config' command has failed."
        _DEFINE_OK=0
        return
      fi
      export ASGS_CONFIG=${ABS_PATH}
      echo "${I} ASGS_CONFIG is now defined as '${ASGS_CONFIG}'"
      ;;
    editor)
      export EDITOR=${2}
      echo "${I} EDITOR is now defined as '${EDITOR}'"
      ;;
    hostfile)
      export ASGS_MPI_HOSTFILE=${2}
      echo "${I} ASGS_MPI_HOSTFILE is now defined as '${ASGS_MPI_HOSTFILE}'"
      ;;
    scriptdir)
      export SCRIPTDIR=${2}
      echo "${I} SCRIPTDIR is now defined as '${SCRIPTDIR}'"
      ;;
    workdir)
      export WORK=${2}
      echo "${I} WORK is now defined as '${WORK}'"
      ;;
    scratchdir)
      export SCRATCH=${2}
      echo "${I} SCRATCH is now defined as '${SCRATCH}'"
      ;;
    *) echo "define requires one of the supported parameters: adcircdir, adcircbranch, adcircremote, config, editor, hostfile, scratchdir, scriptdir, or workdir"
      _DEFINE_OK=0
      ;;
  esac
  if [ 1 -eq "$_DEFINE_OK" ]; then
    save profile
  fi
}

# interactive dialog for choosing an EDITOR if not defined
_editor_check() {
  if [ -z "$EDITOR" ]; then
    __DEFAULT_EDITOR=vim
    echo "\$EDITOR is not defined. Please define it now (selection updates environment):"
    echo
    echo "Editors available via PATH"
    for e in vim nano vi; do
      full=$(which `basename $e`)
      echo "- $e	(full path: $full)"
    done
    read -p "Choose [vim]: " _DEFAULT_EDITOR
    if [ -z "$_DEFAULT_EDITOR" ]; then
      _DEFAULT_EDITOR=$__DEFAULT_EDITOR
    fi
    define editor "$_DEFAULT_EDITOR"
    save profile
    echo
  fi
}

# opens up $EDITOR to directly edit files defined by the case
# statement herein
edit() {
  # if it's not defined
  _editor_check

  # dispatch subject of edit command
  case "${1}" in
  adcirc)
    BRANCH=${2}
    if [ ! -e "$ADCIRC_META_DIR/$BRANCH" ]; then
      echo "$I An ADCIRC environment named '$BRANCH' doesn't exist"
      return
    fi
    $EDITOR "$ADCIRC_META_DIR/$BRANCH"
    ;;
  asgs-global)
    if [ -e "$HOME/asgs-global.conf" ]; then
      $EDITOR $HOME/asgs-global.conf
    else
      echo "$W $HOME/asgs-global.conf doesn't exist."
    fi
    ;;
  asgsh-profile)
    if [ -e "$HOME/.asgsh_profile" ]; then
      $EDITOR $HOME/.asgsh_profile
    else
      echo "$I $HOME/.asgsh_profile doesn't exist, which is fine because it is an optional."
    fi
    ;;
  config)
    if [ -z "$ASGS_CONFIG" ]; then
      echo "$W \$ASGS_CONFIG is not defined. Use 'define config' to specify an ASGS config file."
      return
    elif [ ! -e "$ASGS_CONFIG" ]; then
      echo "$I ASGS_CONFIG file, '$ASGS_FILE' doesn't exist"
      return
    fi
    $EDITOR $ASGS_CONFIG
    if [ 0 -eq $? ]; then
      read -p "reload edited profile '$_ASGSH_CURRENT_PROFILE'? [y]" reload
      if [[ -z "$reload" || "$reload" = "y" ]]; then
        rl
      else
        echo "$W profile '$ASGS_CONFIG' has been edited, but the profile has not been reloaded. To reload, use the 'rl' or 'load profile $_ASGSH_CURRENT_PROFILE' command."
      fi
    fi
    ;;
  hostfile)
    if [ -e "$ASGS_MPI_HOSTFILE" ]; then
      $EDITOR $ASGS_MPI_HOSTFILE
    else
      echo $I "ASGS_MPI_HOSTFILE is not defined or is not set. It's current value is '$ASGS_MPI_HOSTFILE'"
    fi
    ;;
  mail-log)
    if [ -e "$SCRIPTDIR/mail.log" ]; then
      $EDITOR $SCRIPTDIR/mail.log
    else
      echo $I "$SCRIPTDIR/mail.log doesn't exist yet because asgs-sendmail has not yet sent anything."
    fi
    ;;
  meshes)
    $EDITOR $ASGS_MESH_DEFAULTS
    ;;
  platforms)
    $EDITOR $ASGS_PLATFORMS
    ;;
  profile)
    NAME=${2:-"$_ASGSH_CURRENT_PROFILE"}
    if [[ -z "$NAME" || ! -e "$ASGS_META_DIR/$NAME" ]]; then
      echo "$I An ASGS profile named '$NAME' doesn't exist"
      return
    fi
    $EDITOR "$ASGS_META_DIR/$NAME"
    # offer to reload if profile edited/inspected is also the current profile
    if [[ 0 -eq $? && "$NAME" == "$_ASGSH_CURRENT_PROFILE" ]]; then
	    read -p "reload current profile (if modified)'$_ASGSH_CURRENT_PROFILE'? [y]" reload
      if [[ -z "$reload" || "$reload" = "y" ]]; then
        rl
      else
        echo "$W profile '$_ASGSH_CURRENT_PROFILE' has been edited, but not reloaded. To reload, use the 'rl' or 'load profile $_ASGSH_CURRENT_PROFILE' command."
      fi
    fi
    ;;
  ssh-config)
    if [ ! -e "$HOME/.ssh/config" ]; then
      echo "$W '$HOME/.ssh/config' can't be found - ASGS relies on this, so might want to investigate."
      return
    fi
    $EDITOR $HOME/.ssh/config
    ;;
  statefile)
    if [ -z "$STATEFILE" ]; then
      echo "$I STATEFILE is not defined. Perhaps you have not defined a config or loaded a completed profile file yet?"
      _unset_statevars
      return
    elif [ ! -e "$STATEFILE" ]; then
      echo "$I STATEFILE file, '$STATEFILE' doesn't exist."
      _unset_statevars
      return
    fi
    $EDITOR "$STATEFILE"
    ;;
  syslog)
    if [ -z "$SYSLOG" ]; then
      echo "SYSLOG is not defined. Perhaps you have not defined a config or loaded a completed profile file yet?"
    elif [ ! -e "$SYSLOG" ]; then
      echo "$I Log file, '$SYSLOG' doesn't exist - did it get moved or deleted?"
      return
    fi
    $EDITOR "$SYSLOG"
    ;;
  *)
    echo "Supported options:"
    echo "adcirc <NAME>  - named ADCIRC environment file"
    echo "asgs-global    - global settings, including asgs-sendmail configuration information"
    echo "asgsh-profile  - optional ASGS Shell customizations, ~/.asgsh_profile"
    echo "config         - ASGS_CONFIG file, if defined"
    echo "mail-log       - log created by asgs-sendmail"
    echo "meshes         - mesh defaults file"
    echo "platforms      - old platforms.sh file"
    echo "profile <NAME> - named ASGS profile (should be followed up with the 'load profile' command"
    echo "ssh-config     - location of remote server aliases used by ASGS"
    echo "statefile      - STATEFILE from a run in EDITOR for easier forensics"
    echo "syslog         - SYSLOG from a run in EDITOR for easier forensics"
    ;;
  esac
}

# deletes a saved profile by name
delete() {
  case "${1}" in
    adcirc)
      if [ -z "${2}" ]; then
        echo \'delete adcirc\' requires a name parameter, does NOT unload current ADCIRC settings
        return
      fi
      NAME=${2}
      if [ -e "$ADCIRC_META_DIR/$NAME" ]; then
        rm -f "$ADCIRC_META_DIR/$NAME"
        echo deleted ADCIRC configuration \'$NAME\'
      else
        echo "no saved ADCIRC configuration named '$NAME' was found"
      fi
      ;;
    config)
      if [ -z "$ASGS_CONFIG" ]; then
        echo "Config file not yet defined."
        return
      elif [ ! -e "$ASGS_CONFIG" ]; then
        echo "Can't find config fie, $ASGS_CONFIG"
        return
      fi
      read -p "Are you sure you want to delete the '$ASGS_CONFIG'?[y] " delete
      if [[ -z "$delete" || "$delete" = "y" ]]; then
         rm -f $ASGS_CONFIG
         export ASGS_CONFIG=
        echo "Deleted config file and unset 'config' for this profile."
      fi
      save profile $_ASGSH_CURRENT_PROFILE
      ;;
    profile)
      if [ -z "${2}" ]; then
        echo \'delete profile\' requires a name parameter, does NOT unload current profile
        return
      fi
      NAME=${2}
      if [ -e "$ASGS_META_DIR/$NAME" ]; then
        rm -f "$ASGS_META_DIR/$NAME"
        echo deleted profile \'$NAME\'
      else
        echo "no saved profile named '$NAME' was found"
      fi
      ;;
    statefile)
     load profile $_ASGSH_CURRENT_PROFILE
     if [[ -z "${STATEFILE}" ]]; then
       echo STATEFILE is not defined.
       _unset_statevars
       return
     elif [[ ! -e "${STATEFILE}" ]]; then
       echo "STATEFILE, '${STATEFILE}', does not exist."
       _unset_statevars
       return
     fi
     read -p "Delete the state file, \"${STATEFILE}\". [y/N]? " DELETE_STATEFILE
     if [[ 'y' == "${DELETE_STATEFILE}" ]]; then
       rm -rvf "${STATEFILE}"
       _unset_statevars # also unsets STATEFILE
     else
       echo "Purge of state file cancelled."
     fi
    ;;
    *)
      echo "'delete' requires 2 parameters for 'adcirc' and 'profile' specifying which ADCIRC build or profile to delete. All others do not: 'config' and 'statefile'."
      return
  esac
}

# moves out of the way
move() {
  case "${1}" in
    statefile)
     load profile $_ASGSH_CURRENT_PROFILE
     if [[ -z "${STATEFILE}" || ! -e "${STATEFILE}" ]]; then
       echo "${W} '${STATEFILE}' is not set or doesn't exist."
       _unset_statevars
       return
     fi
     read -p "Move state file, \"${STATEFILE}\" [y/N]? " MOVE_STATEFILE
     if [ 'y' == "${MOVE_STATEFILE}" ]; then
       _epoch=$(date +%s)
       mv -vf "${STATEFILE}" "${STATEFILE}.$$.${_epoch}"
       _unset_statevars
     else
       echo "move of state file cancelled."
     fi
    ;;
    syslog)
     load profile $_ASGSH_CURRENT_PROFILE
     if [[ -z "${SYSLOG}" || ! -e "${SYSLOG}" ]]; then
       echo "${W} '${SYSLOG}' is not set or doesn't exist."
       return
     fi
     read -p "Move syslog file, \"${SYSLOG}\" [y/N]? " MOVE_SYSLOG
     if [ 'y' == "${MOVE_SYSLOG}" ]; then
       _epoch=$(date +%s)
       mv -vf "${SYSLOG}" "${SYSLOG}.$$.${_epoch}"
     else
       echo "move of syslog file cancelled."
     fi
    ;;
    *)
      echo "'move' only supports 'statefile', 'syslog' at this time ..."
      return
  esac
}

purge() {
  if [ -z "${1}" ]; then
    echo "'purge' requires 1 argument - currently only supports 'rundir' and 'scratchdir''."
    return
  fi
  case "${1}" in
    rundir)
     read -p "Delete the current run directory, \"${RUNDIR}\" [y/N]? " DELETE_RUNDIR
     if [ 'y' == "${DELETE_RUNDIR}" ]; then
       rm -rvf "${RUNDIR}"
       _unset_statevars # unsets RUNDIR
     else
       echo "Purge of rundir cancelled."
     fi
    ;;
    scratchdir)
     read -p "Delete EVERYTHING in the SCRATCH directory, \"${SCRATCH}\" [y/N]? " DELETE_SCRATCH
     if [ 'y' == "${DELETE_SCRATCH}" ]; then
       rm -rvf ${SCRATCH}/*
     else
       echo "Purge of scratch directory cancelled."
     fi
    ;;
    *)
     echo "'${1}' is not supported. 'purge' currently only supports 'rundir' and 'scratchdir'."
    ;;
  esac
}

if [ 1 = "${skip_platform_profiles}" ]; then
  echo "(-x used) ... skipping the loading platform.sh and properties.sh ..."
else
  if [ -n "$_asgsh_splash" ]; then
    echo "${I} initializing ASGS ..."
  fi
  # loading support for reading of run.properties file
  if [ -e "$SCRIPTDIR/properties.sh" ]; then
    if [ -n "$_asgsh_splash" ]; then
      echo "${I} found properties.sh"
    fi
    source $SCRIPTDIR/properties.sh
  else
    echo "${W} could not find $SCRIPTDIR/properties.sh"
  fi
  # initializing ASGS environment and platform, based on $asgs_machine_name
  if [ -e "$SCRIPTDIR/monitoring/logging.sh" ]; then
    if [ -n "$_asgsh_splash" ]; then
      echo "${I} found logging.sh"
    fi
    source $SCRIPTDIR/monitoring/logging.sh
    if [ -e "$SCRIPTDIR/platforms.sh" ]; then
      if [ -n "$_asgsh_splash" ]; then
        echo "${I} found platforms.sh"
      fi
      source $SCRIPTDIR/platforms.sh
      env_dispatch "$ASGS_MACHINE_NAME" "$PLATFORM_INIT"
    else
      echo "${W} could not find $SCRIPTDIR/platforms.sh"
    fi
  else
    echo "${W} could not find $SCRIPTDIR/monitoring/logging.sh"
  fi
fi

# initialization, do after bash functions have been loaded
source $SCRIPTDIR/etc/PS1.sh

# 'build' is basically ASGS Shell Environment's "package manager"
# these are the "optional" installs - from individual utilities
# to "bundles" (e.g., a set of related, but optional Perl modules)
build() {
  TO_BUILD=${1}
  shift
  BUILD_OPTS=$@
  case "${TO_BUILD}" in
    adcirc)
      init-adcirc.sh $@
      ;;
    jq)
      init-jq.sh ${ASGS_INSTALL_PATH} ${BUILD_OPTS}
      ;;
    pdl)
      init-perl-data-language.sh ${ASGS_INSTALL_PATH} ${BUILD_OPTS}
      ;;
    perl-dev)
      init-perldev-env.sh ${ASGS_INSTALL_PATH} ${BUILD_OPTS}
      ;;
    replaycli)
      init-replaycli.sh ${ASGS_INSTALL_PATH} ${BUILD_OPTS}
      ;;
    *)
      echo 'Supported "build" options:'
      echo '  adcirc    - ADCIRC build wizard supporting different versions and patchsets'
      echo '  jq        - "a lightweight and flexible command-line JSON processor"'
      echo '  pdl       - installs the latest version of the Perl Data Language (PDL)'
      echo '  perl-dev  - installs tools useful for Perl development (e.g., Dist::Zilla)'
      echo '  replaycli - a client for StormReplay.com, an ASGS related service'
      ;;
  esac
}

# deprecation (may change *again* if we create a general install manager
initadcirc(){
  echo "(deprecation notice): 'initadcirc' should now be called as, 'build adcirc'."
  echo "No action taken..."
  echo
  return
}

# alias to edit that may be more semantically correct in some
# cases; e.g., "inspect statefile" or "inspect log"
cpan() { # disable
  echo 'To install a Perl module, use "cpanm" instead.'
}

inspect() {
  edit $@
}

# function alias for `goto dir` command
g() {
  goto $@
}

tmux() {   # disable call tmux inside of asgsh
  echo 'The use of the "tmux" utility *inside* of asgsh is strongly discouraged.'
}

screen() { # disable call tmux inside of asgsh
  echo 'The use of the "screen" utility *inside* of asgsh is strongly discouraged.'
}

# common aliases users expect - if you see something missing, please create a github issue
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'

# handy aliases for the impatient
alias ap="alias -p"
alias a="list adcirc"
alias c="edit config"
alias ds="delete statefile"
alias p="list profiles"
alias m="inspect meshes"
alias lm="list meshes"
alias r="run"
alias rd="goto rundir"
alias sd="goto scriptdir"
alias lsd="goto lastsubdir"
alias s="goto scratchdir"
alias t="tailf syslog"
alias v="verify"
alias va="verify adcirc"
alias ve="verify email"
alias vp="verify perl"
alias vr="verify regressions"
alias vs="verify ssh_config"

# aliases for common git repos used during operations 
alias aconfigs="goto $SCRIPTDIR/git/asgs-configs/$(date +%Y)"              # cd in this year's directory in git/asgs-configs
alias amond="goto $SCRIPTDIR/git/asgs-mon"                                 # cd into asgs-mon's directory
alias amonv="asgs-mon -v"                                                  # run 'asgs-mon -v' (it's in PATH)
alias cera="goto $SCRIPTDIR/git/cera-asgs-environment"                     # cd into cera-asgs-environment's directory
alias cerad="goto $SCRIPTDIR/git/cera-asgs-environment/asgs-configs-daily" # cd into cera-asgs-environment's daily configs directory
alias ceralocal="goto $SCRIPTDIR/git/cera-asgs-local-assets"               # cd into asgs-local-assets
alias docsd="goto $SCRIPTDIR/git/asgs.wiki"                                # cd into asgs.wiki's directory
alias gc="goto configdir"                                                  # cd to the directory containing ASGS_CONFIG if set

if [ -n "$_asgsh_splash" ]; then
# show important directories
  show scriptdir
  goto scriptdir
else
  goto scriptdir >/dev/null 2>&1
fi

# source command completions
if [ -n "$_asgsh_splash" ]; then
  echo "${I} loading command completion definitions"
fi
for C in $(ls $SCRIPTDIR/etc/bash-completions); do
  source $SCRIPTDIR/etc/bash-completions/$C
done

# when started, ASGS Shell loads the 'default' profile,
# this can be made variable at some point
load profile ${profile:-"default-asgs"}

if [ -n "$_asgsh_splash" ]; then
  show scratchdir
  show workdir
  show machinename
  show platform_init
  show adcirccompiler
  show asgslocaldir
  echo
  echo "${YW}${B}Quick start:${R}"
  echo "  'build adcirc' to build and local register versions of ADCIRC"
  echo "  'list profiles' to see what scenario package profiles exist"
  echo "  'load profile <profile_name>' to load saved profile"
  echo "  'list adcirc' to see what builds of ADCIRC exist"
  echo "  'load adcirc <adcirc_build_name>' to load a specific ADCIRC build"
  echo "  'run' to initiated ASGS for loaded profile"
  echo "  'help' for full list of options and features"
  echo "  'verify' the current ASGS Shell Environment is set up properly"
  echo "  'exit' to return to the login shell"
  echo
fi

# construct to handle "autorun" options
case "$_asgsh_flag_do" in
  run_any)
    eval "${_asgsh_flag_do_cmd}"
    exit
  ;;
  run_list)
    list ${_asgsh_flag_do_args}
    exit
  ;;
  run_profile)
    run
  ;;
  run_tailf_syslog)
    tailf syslog
  ;;
  run_verify_and_quit)
    verify
    exit
  ;;
  *)
  ;;
esac
