#!/usr/bin/env perl
package local::bin::adcirclive;

# from core
use v5.010;
use strict;
use warnings;
use Fcntl ':mode';
use Getopt::Long qw(GetOptionsFromArray);
use FindBin qw($Bin);
use lib qq{$Bin/../lib};

# from local lib (should be fatpack'd for distribution)
use Config::Tiny;
use App::Perlbrew::HTTP qw(http_user_agent_program http_download http_get http_postJSON);

use constant {
    FORCE        => 1,
    EXIT_SUCCESS => 0,
    EXIT_ERROR   => 255,
    HOME         => ( getpwuid($<) )[7],
};

#
# Config file - read or initialize
#
my $config_file = sprintf(qq{%s/asgs-global.conf}, HOME);
my $config = undef;
if (-e $config_file) {
  my $_mode         = (stat($config_file))[2];
  my $user_rwx      = ($_mode & S_IRWXU) >> 6;
  my $group_read    = ($_mode & S_IRGRP) >> 3;
  my $other_execute = $_mode & S_IXOTH;
  my $mode = sprintf "%d%d%d", $user_rwx, $group_read, $other_execute;
  if ($mode ne 600) {
    warn qq{"$config_file" found, but not set to 0600. Fixing. ...\n};
    chmod 0600, $config_file; 
  }
  $config = Config::Tiny->read($config_file);
}
else {
  warn <<EOF;

Configuration file, "$config_file", not found. Creating empty
file, "$config_file". Functionality will be limited until
valid credentials are added.

EOF

  open my $fh, q{>}, $config_file or die $!;
  print $fh <<EOF;
;
; please update with proper information, either manually or
; by using the "adcirclive config set" command
;
[adcirclive]
apikey=<get from tools.adcirc.live>
secretkey=<get from tools.adcirc.live>

[email]
from_address=your\@email.address
reply_to_address=your\@email.address
smtp_host=email-smtp.us-east-1.amazonaws.com
smtp_password=<get from ASGS lead operator>
smtp_port=587
smtp_username=<get from ASGS lead operator>
EOF
  close $fh;
  chmod 0600, $config_file; 
}

#http_download('https://cpan.metacpan.org/authors/id/L/LO/LORtN/LWP-Curl-0.14.tar.gz', '/tmp/test.tar.gz', FORCE);
#my $url  = q{https://api.restful-api.dev/objects};
#my $json = '{"name":"Apple MacBook Pro 16","data":{"year":2019,"price":2049.99,"CPU model":"Intel Core i9","Hard disk size":"1 TB","color":"silver"}}';
#print http_postJSON($url, $json);

#my $ret  = GetOptionsFromArray($ARGV, $opts, qw/foo=s/);
#require Data::Dumper;
#print Data::Dumper::Dumper($opts);

my $subcommand = shift @ARGV;

my $subcommands = {

    # in progress
    auth     => sub {cmd_auth(\@ARGV)},       # verifies if auth info in ~/asgs-global.conf works at tools.adcirc.live for API access
    activate => sub {cmd_activate(\@ARGV)},   # initialization wizard
    asgsh    => sub {cmd_asgsh(\@ARGV)   },   # general passthrough command to asgs (run anything without a direct command)
    shell    => sub {cmd_shell(\@ARGV)   },   # run asgsh (ASGS Shell)

    # pmuch done
    build  => sub {cmd_build(\@ARGV)  },   # primarily access to "asgs build adcirc"
    config => sub {cmd_config(\@ARGV) },   # general setting of configs (like, "git config")
    list   => sub {cmd_list(\@ARGV)   },   # primarily to list adcirc versions

    # TODO; not started
    use    => sub { },                       # primarily to select and adcirc version to load
    xdmf   => sub { },                       # tools.adcirc.live API call
    xdmftv => sub { },                       # tools.adcirc.live API call
    update => sub {cmd_update(\@ARGV) },   # run "update-asgs"
};

if ( $subcommands->{$subcommand} ) {
    exit $subcommands->{$subcommand}->();
}

warn qq{"$subcommand" is not a supported subcommand!\n};
exit EXIT_ERROR;

sub cmd_activate {
  print qq{Please enter your user key from https://tools.adcirc.live: };
  my $userkey = <STDIN>; 
  chomp $userkey;
  my $stty_orig = `stty -g`;
  `stty -echo`;
  print qq{Please enter your secret key from https://tools.adcirc.live: };
  my $secretkey = <STDIN>; 
  chomp $secretkey;
  `stty $stty_orig`;

  # update $config_file
  $config->{adcirclive}->{userkey}   = $userkey;
  $config->{adcirclive}->{secretkey} = $secretkey;
  $config->write($config_file);

  # make curl-based call here to verify - maybe equivalent to "cmd_auth"

  print qq{\nConfiguration updated!\n};

  return EXIT_SUCCESS;
}

# subcommand add a configuration to $config_file 
sub cmd_config {
    my $ARGV    = shift;
    my $action  = shift @$ARGV; # looking for 'get' or 'set'

    # dump help section if no supported $action is specified
    if (not $action or not grep {/$action/} qw/delete dump get set/) {
      cmd_config_help();
      return EXIT_ERROR;
    }

    # catch "dump" early, do it, the return success
    if ($action eq "dump") {
      print $config->write_string;
      return EXIT_SUCCESS;
    }

    my $command = join " ", @$ARGV; # command is everything left on the commandline
    my ($var, $value)    = split /[ =]+/, $command;

    my ($section, $name) = split /\./, $var;
    if (not $section or not $name) {
      my $msg = qq{"$var" is not a valid configuration variable identifier, requires the form: SECTION.NAME};
      cmd_config_help($msg);
      return EXIT_ERROR;
    } 

    # perform actions
    if ($action eq "get") {
      if (not exists $config->{$section}->{$name}) {
        my $msg = qq{"$section.$name" does not exist in $config_file};
        cmd_config_help($msg);
        return EXIT_ERROR;
      } 
      printf qq{%s: "%s"\n}, $var, $config->{$section}->{$name};
    }
    elsif ($action eq "delete") {
      if (not exists $config->{$section}->{$name}) {
        my $msg = qq{"$section.$name" does not exist in $config_file};
        cmd_config_help($msg);
        return EXIT_ERROR;
      } 
      delete $config->{$section}->{$name};
      printf qq{%s: deleted!\n}, $var;
      $config->write($config_file);
    }
    elsif ($action eq "set" and $value) {
      if (not exists $config->{$section}->{$name}) {
        my $msg = qq{"$section.$name" does not exist in $config_file};
        cmd_config_help($msg);
        return EXIT_ERROR;
      } 
      my $old = $config->{$section}->{$name};
      $config->{$section}->{$name} = $value;
      printf qq{%s: "%s" -> "%s"\n}, $var, $old, $config->{$section}->{$name};
      $config->write($config_file);
    }
    return EXIT_SUCCESS;
}

sub cmd_config_help(;$) {
      my $message = shift // q{};
      my $header  = q{};
      if ($message) {
        $header = <<EOF;
Message:
  $message
EOF
      }
      warn <<EOF;
$header
Usage:
  adcirclive delete|dump|get|set [section.setting [VALUE]]

To see all values, use the 'dump' action,

  adcirclive config dump

To set a value, use the 'set' action,

  adcirclive config set adcirclive.key "some value"
  adcirclive config set adcirclive.secret "some other value"

To show a specific value, use the 'get' action,

  adcirclive config get adcirclive.key

To delete a variable or whole section, use the 'delete' action,

  adcirclive config delete adcirclive.secret

  note: if you want to delete an entire section, you will have to manually edit
  the configuration file, "$config_file".

For more information, contact us at:

 paid priority support: tools-help\@support.adcirc.live
 free general support:  hello\@support.adcirc.live

EOF
}


# subcommand to run any ASGS script available via a profile's PATH
sub cmd_asgsh {
    my $ARGV            = shift;
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile = $opts->{profile};
    my $command = join q{ }, @$ARGV; # command is everything left on the commandline
    if (not $command) {
      warn qq{Usage:\n\tadcirclive asgsh <COMMAND>"\n};
      return EXIT_ERROR;
    }
    my $exit_code = system(<<EOCMD);
      asgsh -p $profile -A "$command"      # quotes around the command variable are necessary
EOCMD
    return $exit_code;
}

# direct asgsh's "build adcirc"
sub cmd_build {
    my $ARGV = shift;
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile         = $opts->{profile};
    system(<<EOCMD);
      asgsh -A "build adcirc" -p $profile        # run ADCIRC wizard directly
EOCMD
}

# access to asgsh's "list" command
sub cmd_list {
    my $thing = shift @$ARGV // q{adcirc};
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile         = $opts->{profile};
    system(<<EOCMD);
      asgsh -A "list $thing" -p $profile | awk '{print \$2}' # list "things" - uses 'awk' to strip out enumerated numbers
EOCMD
}

# direct asgsh's "build adcirc"
sub cmd_update {
    my $ARGV = shift;
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile         = $opts->{profile};
    system(<<EOCMD);
      update-asgs --update-shell
EOCMD
}

1;
