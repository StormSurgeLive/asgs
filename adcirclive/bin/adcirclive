#!/usr/bin/env perl
package local::bin::adcirclive;

# from core
use v5.010;
use strict;
use warnings;
use Getopt::Long qw(GetOptionsFromArray);
use FindBin qw($Bin);
use lib qq{$Bin/../lib};

# from local lib (should be fatpack'd for distribution)
use Config::Tiny;
use App::Perlbrew::HTTP qw(http_user_agent_program http_download http_get http_postJSON);

use constant {
    FORCE        => 1,
    EXIT_SUCCESS => 0,
    EXIT_ERROR   => 255,
    HOME         => ( getpwuid($<) )[7],
};

my $config = Config::Tiny->read(sprintf(qq{%s/asgs-global.conf}, HOME));

#http_download('https://cpan.metacpan.org/authors/id/L/LO/LORtN/LWP-Curl-0.14.tar.gz', '/tmp/test.tar.gz', FORCE);
#my $url  = q{https://api.restful-api.dev/objects};
#my $json = '{"name":"Apple MacBook Pro 16","data":{"year":2019,"price":2049.99,"CPU model":"Intel Core i9","Hard disk size":"1 TB","color":"silver"}}';
#print http_postJSON($url, $json);

#my $ret  = GetOptionsFromArray($ARGV, $opts, qw/foo=s/);
#require Data::Dumper;
#print Data::Dumper::Dumper($opts);

my $subcommand = shift @ARGV;

my $subcommands = {
    asgs   => sub { cmd_asgs( \@ARGV ) },     # general passthrough command to asgs (run anything without a direct command)
    build  => sub { cmd_build( \@ARGV ) },    # primarily access to "asgs build adcirc"
    list   => sub { cmd_list( \@ARGV ) },     # primarily to list adcirc versions

    auth   => sub { },                        # set config information, default is to store it in ~/asgs-global.conf
    config => sub { },                        # general setting of configs (like, "git config")
    use    => sub { },                        # primarily to select and adcirc version to load
    xdmf   => sub { },                        # tools.adcirc.live API call
    xdmftv => sub { },                        # tools.adcirc.live API call
};

if ( $subcommands->{$subcommand} ) {
    exit $subcommands->{$subcommand}->();
}

warn qq{"$subcommand" is not a supported subcommand!\n};
exit EXIT_ERROR;

# subcommand to run any ASGS script available via a profile's PATH
sub cmd_asgs {
    my $ARGV            = shift;
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile 
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile = $opts->{profile};
    my $command = join q{ }, @$ARGV; # command is everything left on the commandline
    if (not $command) {
      warn qq{Usage:\n\tadcirclive asgs <COMMAND>"\n};
      return EXIT_ERROR;
    }
    my $exit_code = system(<<EOCMD);
      asgsh -A "$command" -p $profile            # quotes around the command variable are necessary
EOCMD
    return $exit_code;
}

# direct asgsh's "build adcirc"
sub cmd_build {
    my $ARGV = shift;
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile 
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile         = $opts->{profile};
    system(<<EOCMD);
      asgsh -A "build adcirc" -p $profile        # run ADCIRC wizard directly
EOCMD
}

# access to asgsh's "list" command
sub cmd_list {
    my $thing = shift @$ARGV // q{adcirc};
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile 
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile         = $opts->{profile};
    system(<<EOCMD);
      asgsh -A "list $thing" --profile $profile | awk '{print \$2}' # list "things" - uses 'awk' to strip out enumerated numbers 
EOCMD
}

1;
