#!/usr/bin/env perl
package local::bin::adcirclive;

# from core
use v5.010;
use strict;
use warnings;
use Fcntl ':mode';
use Getopt::Long qw(GetOptionsFromArray);
use FindBin qw($Bin);
use lib qq{$Bin/../lib};

# from local lib (should be fatpack'd for distribution)
use Config::Tiny;
use App::Perlbrew::HTTP qw(http_user_agent_program http_download http_get http_postJSON);

use constant {
    FORCE        => 1,
    EXIT_SUCCESS => 0,
    EXIT_ERROR   => 255,
    HOME         => ( getpwuid($<) )[7],
};

#
# Config file - read or initialize
#
my $config_file = sprintf(qq{%s/asgs-global.conf}, HOME);
my $config = undef;
if (-e $config_file) {
  my $_mode         = (stat($config_file))[2];
  my $user_rwx      = ($_mode & S_IRWXU) >> 6;
  my $group_read    = ($_mode & S_IRGRP) >> 3;
  my $other_execute = $_mode & S_IXOTH;
  my $mode = sprintf "%d%d%d", $user_rwx, $group_read, $other_execute;
  if ($mode ne 600) {
    warn qq{"$config_file" found, but not set to 0600. Fixing. ...\n};
    chmod 0600, $config_file; 
  }
  $config = Config::Tiny->read($config_file);
}
else {
  warn <<EOF;

Configuration file, "$config_file", not found. Creating empty
file, "$config_file". Functionality will be limited until
valid credentials are added.

EOF

  open my $fh, q{>}, $config_file or die $!;
  print $fh <<EOF;
;
; please update with proper information, either manually or
; by using the "adcirclive config define" command
;
[authentication]
apikey=<get from tools.adcirc.live>
secretkey=<get from tools.adcirc.live>

[email]
from_address=your\@email.address
reply_to_address=your\@email.address
smtp_host=email-smtp.us-east-1.amazonaws.com
smtp_password=<get from ASGS lead operator>
smtp_port=587
smtp_username=<get from ASGS lead operator>
EOF
  close $fh;
  chmod 0600, $config_file; 
}

#my $ret  = GetOptionsFromArray($ARGV, $opts, qw/foo=s/);
#require Data::Dumper;
#print Data::Dumper::Dumper($opts);
sub cmd_auth {
    my $ARGV    = shift;

# http_postJSON ...:q
#http_download('https://cpan.metacpan.org/authors/id/L/LO/LORtN/LWP-Curl-0.14.tar.gz', '/tmp/test.tar.gz', FORCE);
#my $url  = q{https://api.restful-api.dev/objects};
#my $json = '{"name":"Apple MacBook Pro 16","data":{"year":2019,"price":2049.99,"CPU model":"Intel Core i9","Hard disk size":"1 TB","color":"silver"}}';
#print http_postJSON($url, $json);

}

my $subcommand = shift @ARGV;

my $subcommands = {

    # in progress
    show     => sub {cmd_show(\@ARGV) },
    define   => sub {cmd_define(\@ARGV) },

    # TODO; not started
    activate => sub {cmd_activate(\@ARGV)},             # initialization wizard
    auth     => sub {cmd_auth(\@ARGV)},                 # verifies if auth info in ~/asgs-global.conf works at tools.adcirc.live for API access
    asgsh    => sub {cmd_asgsh(\@ARGV)   },             # general passthrough command to asgs (run anything without a direct command)
    shell    => sub {cmd_shell(\@ARGV)   },             # run asgsh (ASGS Shell)
    build    => sub {cmd_build(\@ARGV)  },   # primarily access to "asgsh build adcirc"
    list     => sub {cmd_list(\@ARGV)   },   # primarily to list adcirc versions
    use      => sub { },                       # primarily to select and adcirc version to load
    xdmf     => sub { },                       # tools.adcirc.live API call
    xdmftv   => sub { },                       # tools.adcirc.live API call
    update   => sub {cmd_update(\@ARGV) },   # run "update-asgs"
};

if ( $subcommands->{$subcommand} ) {
    exit $subcommands->{$subcommand}->();
}

warn qq{"$subcommand" is not a supported subcommand!\n};
exit EXIT_ERROR;

# subcommand add a configuration to $config_file 
sub cmd_define {
    my $ARGV    = shift;

    # expecting only 2 more things, full config variable name and new value
    if (@$ARGV != 2) {
      warn qq{(error) expecting exactly 2 arguments\n\t  adcirclive define section.variable value\n};
      return EXIT_ERROR;
    }

    my ($var, $value)    = @$ARGV; # everything left on the commandline
    my @var_parts = split /\./, $var;

    # expecting only parts of a fully defined config variable name; SECTION.VARNAME
    if (@var_parts != 2) {
      warn qq{(error) expecting a fully qualified config variable name\n\t  adcirclive define section.variable value\n};
      return EXIT_ERROR;
    }

    my ($section, $varname) = @var_parts;

    if (not exists $config->{$section}->{$varname}) {
      warn sprintf(qq{(warn) variable %s doesn't exist, creating ...\n}, $var);
    }
    
    my $oldvalue = $config->{$section}->{$varname} // q{};

    $config->{$section}->{$varname} = $value;
    $config->write($config_file);
    printf qq{defined %s: "%s" -> "%s"\n}, $var, $oldvalue, $value;
    return EXIT_SUCCESS;
}

# subcommand add a configuration to $config_file 
sub cmd_show {
    my $ARGV    = shift;

    my $var     = shift @$ARGV // q{}; # everything left on the commandline
    my ($section, $name) = split /\./, $var;

    if (not $section or not $name) {
      print qq{;;;; $config_file ;;;;\n};
      print $config->write_string();
      print qq{;;;; $config_file ;;;;\n};
    } 
    elsif ($section and $name) {
      if (not exists $config->{$section}->{$name}) {
        my $msg = qq{"$section.$name" does not exist in $config_file};
        cmd_define_help($msg);
        return EXIT_ERROR;
      } 
      printf qq{%s: %s\n}, $var, $config->{$section}->{$name};
    }
    return EXIT_SUCCESS
}

__END__

sub cmd_activate {
  print qq{Please enter your user key from https://tools.adcirc.live: };
  my $userkey = <STDIN>; 
  chomp $userkey;
  my $stty_orig = `stty -g`; # using backticks to capture STDOUT from command
  system qw/stty -echo/;
  print qq{Please enter your secret key from https://tools.adcirc.live: };
  my $secretkey = <STDIN>; 
  chomp $secretkey;
  `stty $stty_orig`;         # reset back to visible echo

  # update $config_file
  $config->{adcirclive}->{userkey}   = $userkey;
  $config->{adcirclive}->{secretkey} = $secretkey;
  $config->write($config_file);

  ## TODO...
  # make curl-based call here to verify - maybe equivalent to "cmd_auth"

  print qq{\nConfiguration updated!\n};

  return EXIT_SUCCESS;
}

# subcommand to run any ASGS script available via a profile's PATH
sub cmd_asgsh {
    my $ARGV            = shift;
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile = $opts->{profile};
    my $command = join q{ }, @$ARGV; # command is everything left on the commandline
    if (not $command) {
      warn qq{Usage:\n\tadcirclive asgsh <COMMAND>"\n};
      return EXIT_ERROR;
    }
    my $exit_code = system(<<EOCMD);
      asgsh -p $profile -A "$command"      # quotes around the command variable are necessary
EOCMD
    return $exit_code;
}

# direct asgsh's "build adcirc"
sub cmd_build {
    my $ARGV = shift;
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile         = $opts->{profile};
    system(<<EOCMD);
      asgsh -A "build adcirc" -p $profile        # run ADCIRC wizard directly
EOCMD
}

# access to asgsh's "list" command
sub cmd_list {
    my $thing = shift @$ARGV // q{adcirc};
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile         = $opts->{profile};
    system(<<EOCMD);
      asgsh -A "list $thing" -p $profile | awk '{print \$2}' # list "things" - uses 'awk' to strip out enumerated numbers
EOCMD
}

# direct asgsh's "build adcirc"
sub cmd_update {
    my $ARGV = shift;
    my $opts->{profile} = q{adcirclive}; # initially, "adcirclive" is a copy of the default profile
    my $ret             = GetOptionsFromArray( $ARGV, $opts, qw/profile=s/ );
    my $profile         = $opts->{profile};
    system(<<EOCMD);
      update-asgs --update-shell
EOCMD
}

1;
