C******************************************************************************
C                                                                             *
C                                                                             *
C  PROGRAM TO EXTRACT TIDAL INFORMATION FROM THE ADCIRC 2DDI TIDAL DATA BASE  *
C     FOR USE AS BOUNDARY CONDITIONS IN ANOTHER MODEL RUN               *
C                                                                             *
C                                                                             *
C     -  DEVELOPED FOR                                                        *
C                                                                             *
C          THE U.S. ARMY ENGINEERS WATERWAYS EXPERIMENT STATION               *
C             UNDER CONTRACT WITH THE DREDGED RESEARCH PROGRAM                *
C                                                                             *
C                                                                             *
C     -  DEVELOPED BY                                                         *
C                                                                             *
C          R.A. LUETTICH, JR                                                  *
C             UNIVERSITY OF NORTH CAROLINA AT CHAPEL HILL                     *
C             INSTITUTE OF MARINE SCIENCES                                    *
C                                                                             *
C          J.J. WESTERINK                                                     *
C             DEPARTMENT OF CIVIL ENGINEERING AND GEOLOGICAL SCIENCES         *
C             UNIVERSITY OF NOTRE DAME                                        *
C                                                                             *
C                                                                             *
C     -  CODED BY                                                             *
C                                                                             *
C          R.A. LUETTICH    VERSION  1.00-1.02                                *
C              "            VERSION  1.04 for ec_95d database                 *
C          C.W. FULCHER     VERSION  1.05 bug fix (in determining the         *
C                                    ascending order of nodes the N2<N3<N1    *
C                                    and the N3<N1<N2 definitions of NO(n)    *
C                                    were switched.)  Corrected 3-22-99       *
C          R.A. LUETTICH    VERSION  1.06 for ec2001_v2d database             *
C          J.G. FLEMING     VERSION  1.07 20110320 Added capability to 
C                           run the code via command line options to facilitate
C                           automation; added code to automatically grab the 
C                           open boundary node locations from an ADCIRC fort.14
C                           (mesh) file; made arrays dynamically allocated;
C                           added implicit none and explicitly declared all
C                           variables. Added comment lines throughout. 
C                           Made all nodal coordinates double precision.
C                                                                             *
C******************************************************************************
C                                                                             *
C                                                                             *
C     -  PARAMETERS WHICH MUST BE SET WITHIN THE MAIN CODE AND THE            *
C          SUBROUTINES TO CONTROL THE DIMENSIONING OF ARRAYS ARE AS FOLLOWS   *
C          (TO FIND THE LINES WHICH MUST BE SET, FIND "CUSER" COMMENT LINES): *
C                                                                             *
C          MNP = MAXIMUM NUMBER OF NODAL POINTS                               *
C          MNHARF = MAXIMUM NUMBER OF CONSTITUENTS IN DATA BASE               *
C                                                                             *
C******************************************************************************
C                                                                             *
C     -  STANDARD INPUT FILES ARE AS FOLLOWS:                                 *
C                                                                             *
C          UNIT 12 : FILE LISTING THE X AND Y COORDINATES OF ALL LOCATIONS FOR*
C                    INTERPOLATED OUTPUT.                                     *
C          UNIT 14 : ADCIRC FINITE ELEMENT GRID FILE                          *
C          UNIT 105 : HARMONIC CONSTITUENT ELEVATIONS AND VELOCITIES AT ALL   *
C                     NODES.  THIS FILE WAS GENERATED BY RUNNING ASTROEX.FOR  *
C                     ON THE UNIT 53 AND UNIT 54 FILES GENERATED BY ADCIRC.   *
C                                                                             *
C     -  DESCRIPTION OF INPUT VARIABLES READ IN FROM UNIT 12 (tides.in)       *
C                                                                             *
C          NOUT = NUMBER OF OUTPUT POINTS IN THE FILE                         *
C          XOUT(I),YOUT(I), I=1,NOUT  =  X AND Y COORDINATES OF EACH POINT TO *
C               INTERPOLATE OUTPUT AT                                         *
C                                                                             *
C     -  DESCRIPTION OF INPUT VARIABLES READ IN FROM UNIT 14 (ec_95d.grd)     *
C                                                                             *
C          AGRID = ALPAHANUMERIC GRID IDENTIFICATION  (<=24 CHARACTERS)       *
C          NE,NP = NUMBER OF ELEMENTS AND NUMBER OF NODAL POINTS RESPECTIVELY *
C          JKI,X(JKI),Y(JKI),DP(JKI) , JKI=1,NP  = NODE NUMBER, X AND Y       *
C               COORDINATES, BATHYMETRIC VALUE ; NODES CAN BE INPUT IN        *
C               ANY ORDER ; IF ICS=1, THEN X,Y REPRESENT STANDARD             *
C               CARTESIAN COORDINATES SPECIFIED IN LENGTH UNITS.              *
C               IF ICS=2, THEN X,Y REPRESENT DEGREES LONGITUDE                *
C               (DEGREES EAST OF GREENWICH IS POSITIVE AND DEGREES WEST OF    *
C               GREENWICH IS NEGATIVE) AND DEGREES LATITUDE (DEGREES          *
C               NORTH OF THE EQUATOR BEING POSITIVE AND DEGREES SOUTH OF THE  *
C               EQUATOR IS NEGATIVE) RESPECTIVELY                             *
C          JKI,NHY,NM(JKI,1),NM(JKI,2),NM(JKI,3) , JKI=1,NE  = ELEMENT        *
C               NUMBER, ELEMENT TYPE, AND ELEMENT CONNECTIVITY SPECIFIED      *
C               WITH A COUNTERCLOCKWISE ORIENTATION ; NOTE THAT THE ELEMENT   *
C               TYPE IS NOT AN ACTIVE VARIABLE AND THAT ONLY 3 NODE           *
C               LINEAR TRIANGLES ARE OPERATIONAL IN THIS VERSION OF THE CODE; *
C               ELEMENTS CAN BE READ IN IN ANY ORDER                          *
C                                                                             *
C     -  DESCRIPTION OF INPUT VARIABLES READ FROM UNIT 105 (ec_95d.tdb)       *
C                                                                             *
C          NHARFR = NUMBER OF CONSTITUENTS IN FILE                            *
C          J=1,NHARF                                                          *
C             FREQUENCY, NODAL FACTOR, EQUILIBRIUM ARGUMENT, CONSTITUENT NAME *
C          NP = NUMBER OF NODES IN GRID                                       *
C          J=1,NP                                                             *
C             J,(HAMP(I),HPHASE(I) I=1,NHARFR)                                *
C               (UAMP(I),UPHASE(I) I=1,NHARFR)                                *
C               (VAMP(I),VPHASE(I) I=1,NHARFR)                                *
C                                                                             *
C******************************************************************************
C                                                                             *
C     -  STANDARD OUTPUT FILE IS AS FOLLOWS:                                  *
C                                                                             *
C          UNIT 1 : TIDAL CONSTITUENT RESULTS                                 *
C          UNIT 2 : DIAGNOSTIC INFORMATION                                    *
C                                                                             *
C                                                                             *
C     -  DESCRIPTION OF OUTPUT DATA WRITTEN TO UNIT 1  (tides.out)            *
C          self explanatory.  see output file.                                *
C                                                                             *
C     -  DESCRIPTION OF OUTPUT DATA WRITTEN TO UNIT 2  (tides.dia)            *
C          self explanatory.  see output file.                                *
C                                                                             *
C******************************************************************************
C     Example of compiling with gfortran:
C     gfortran -ffixed-line-length-none -o ec2001v2d_tide_interp.x ec2001v2d_tide_interp.f 

      PROGRAM EC2001V2D_TIDE_INTERP
      IMPLICIT NONE
C
      REAL, PARAMETER :: PI=3.141592653589793
      CHARACTER(80), PARAMETER :: version = "1.07"
C
      REAL(8), ALLOCATABLE :: X(:),Y(:),XOUT(:),YOUT(:),XLON(:),YLAT(:)
      REAL(8), ALLOCATABLE :: DEPTH(:),DEPTHOUT(:)
      REAL, ALLOCATABLE :: EAMP(:,:),EPHA(:,:)
      REAL, ALLOCATABLE :: ETAMP(:,:), ETPHA(:,:)
C
      REAL, ALLOCATABLE :: UAMP(:,:), UPHA(:,:)
      REAL, ALLOCATABLE :: UTAMP(:,:), UTPHA(:,:)
C
      REAL, ALLOCATABLE :: VAMP(:,:), VPHA(:,:)
      REAL, ALLOCATABLE :: VTAMP(:,:), VTPHA(:,:)
C         
      REAL, ALLOCATABLE :: FREQ(:), NFACT(:), EQARG(:)
      INTEGER, ALLOCATABLE :: NM1(:), NM2(:), NM3(:)
      INTEGER, ALLOCATABLE :: node(:), tnode(:)
      CHARACTER*10, ALLOCATABLE :: HCNAME(:)

      INTEGER :: NNE   ! source element containing the target location
      INTEGER :: NN(3) ! node #s around the source ele containing target loc
      INTEGER :: NO(3)
      INTEGER :: NOUT ! number of target locations for harmonic data
      INTEGER :: TNP  ! number of nodes in the target mesh
      INTEGER :: TNE  ! number of elements in the target mesh
      INTEGER :: NP   ! number of nodes in the source mesh (w/harmonic data)
      INTEGER :: NE   ! number of elements in the source mesh (w/harmonic data)
      INTEGER :: I, JKI, NHY, KMIN, K, N1, N2, N3, N, EN
      INTEGER :: NOPE, NETA, NVDLL 
      INTEGER :: NHC, J, NPP, IBEG, SNODE, II, IDUM, I1, I2, I3
      REAL(8) :: AEMIN, X4, Y4, X1, X2, X3, Y1, Y2, Y3, AREAS, E1R, E1I
      REAL :: E2R, E2I, E3R, E3I, ETR, ETI
      REAL(8) :: STA1, STA2, STA3
      REAL(8) :: A1, A2, A3, AA, AE, AREA
      REAL(8) :: U1I, U1R, U2I, U2R, U3I, U3R, UTI, UTR, V1I, V1R
      REAL(8) :: V2R, V3I, V3R, VTI, VTR, V2I
      CHARACTER(24) :: AGRID
      CHARACTER(24) :: header
      CHARACTER(1024) :: cmdlinearg
      INTEGER :: argcount
      LOGICAL :: adcircFormat !.true. if coords should be omitted from output
      LOGICAL :: includeVelocity ! .true. if velocity harmonics should also be output
      LOGICAL :: outputThisConstituent ! .true. if a const. should be output 
      INTEGER :: numTidalConstituents  ! number of tidal const. to interpolate
      CHARACTER(len=10), ALLOCATABLE :: interpTidalConstituents(:)
      INTEGER, ALLOCATABLE :: constituentList(:)
C
      CHARACTER(1024) :: outfile ! where the results will be written
      CHARACTER(1024) :: logfile 
      CHARACTER(1024) :: targetmesh ! where the tides should be interpolated
      CHARACTER(1024) :: sourcemesh ! where the tidal data is interpolated from
      CHARACTER(1024) :: tidaldb    ! tidal harmonic data file
      CHARACTER(len=1024), dimension(7) :: defaultTidalConstituents ! basic set of 7
      LOGICAL :: FOUND ! true if file exists
C
C     Set reasonable defaults
      outfile = 'tides.out'
      logfile = 'tides.dia'
      targetmesh = 'tides.in'
      sourcemesh = 'ec2001_v2d.grd'      
      tidaldb = 'ec2001_v2d.tdb'
      adcircFormat = .false.
      includeVelocity = .false.
      numTidalConstituents = 7
      defaultTidalConstituents(1) = 'M2'
      defaultTidalConstituents(2) = 'S2'
      defaultTidalConstituents(3) = 'N2'
      defaultTidalConstituents(4) = 'K1'
      defaultTidalConstituents(5) = 'K2'
      defaultTidalConstituents(6) = 'O1'
      defaultTidalConstituents(7) = 'Q1'
C
C     Process command line options, if any
      argcount = iargc()
      if (argcount.gt.0) then
         i = 0
         do while(i.lt.argcount)
            i = i + 1
            call getarg(i, cmdlinearg)
            select case(trim(cmdlinearg))
               case("-o","--outputfile") ! output file name
                  i = i + 1
                  call getarg(i,outfile)
               case("-l","--logfile") ! log file
                  i = i + 1
                  call getarg(i,logfile)
               case("-t","--targetmesh") ! target mesh
                  i = i + 1
                  call getarg(i,targetmesh)
               case("-s","--sourcemesh") ! source mesh
                  i = i + 1
                  call getarg(i,sourcemesh)
               case("-d","--tidaldb") ! data for harmonic tides
                  i = i + 1
                  call getarg(i,tidaldb)
               case("-f","--format") ! format: either full or adcirc-style
                  i = i + 1
                  call getarg(i,cmdlinearg)
                  select case(trim(cmdlinearg))
                     case("full")
                        ! do nothing; incl. coordinates is the default
                     case("adcirc")
                        adcircFormat = .true.                        
                     case default
                        write(*,*) "ERROR: ec2001v2d_tide_interp: -f '",
     &                     trim(cmdlinearg),"' not recognized."
                        stop
                  end select
               case("-n","--numtidalconstituents") ! number of tidal constituents to interpolate
                  i = i + 1
                  call getarg(i,cmdlinearg)
                  read(cmdlinearg,*) numTidalConstituents
                  allocate(interpTidalConstituents(numTidalConstituents))
                  ! then read this many space-separated strings on the command line
                  do j=1, numTidalConstituents
                     i = i + 1
                     call getarg(i,interpTidalConstituents(j))
                  end do
               case("-e","--includevelocity") ! include velocity harmonics in the output
                  includeVelocity = .true.
               case("-v","--version") ! show version information
                  write(*,*) "ec2001v2d_tide_interp version ",version
               case("-h","--help") ! show a help message
                  write(*,*) "-o outfile"
                  write(*,*) "-l logfile"
                  write(*,*) "-s sourcemesh"
                  write(*,*) "-t targetmesh"
                  write(*,*) "-d tidaldb"
                  write(*,*)
     &             "-n number of constitutents followed by their names"
                  write(*,*) "-f full or -f adcirc"
                  write(*,*) "-v show version"
                  write(*,*) "-h this message"
                  stop
               case default
                  write(*,*) "ERROR: ec2001v2d_tide_interp: ",
     &               "Command line option '",
     &               trim(cmdlinearg),"' not recognized."
                  stop
            end select
         end do
      endif ! end processing of command line options, if any
C
C
      ! open the file where the results will be written
      OPEN(1,FILE=trim(outfile),STATUS='replace',action='write')
      ! open a log file
      OPEN(2,FILE=trim(logfile),STATUS='replace', action='write')
      !
      ! open the file containing the target locations
      INQUIRE(FILE=trim(targetmesh),EXIST=FOUND)
      IF (FOUND.EQV..FALSE.) THEN
            write(*,*) "ERROR: ec2001v2d_tide_interp: ",
     &      " The ADCIRC target mesh file '",
     &      trim(targetmesh),"' was not found."
         STOP
      ENDIF
      OPEN(12,FILE=trim(targetmesh),STATUS='old',action='read')
      !
      ! open the source mesh file upon which the tidal data is defined
      INQUIRE(FILE=trim(sourcemesh),EXIST=FOUND)
      IF (FOUND.EQV..FALSE.) THEN
            write(*,*) "ERROR: ec2001v2d_tide_interp: ",
     &      " The ADCIRC source mesh file '",
     &      trim(sourcemesh),"' was not found."
         STOP
      ENDIF
      OPEN(14,FILE=trim(sourcemesh),STATUS='old',action='read')
      !
      ! open the tidal database file
      INQUIRE(FILE=trim(tidaldb),EXIST=FOUND)
      IF (FOUND.EQV..FALSE.) THEN
            write(*,*) "ERROR: ec2001v2d_tide_interp: ",
     &      " The tidal database file '",
     &      trim(tidaldb),"' was not found."
         STOP
      ENDIF
      OPEN(105,FILE=trim(tidaldb),STATUS='old',action='read')
      READ(105,*) NHC
      REWIND(105)
      !
      ! allocate arrays that have the number of tidal constitutents 
      ! in the database as one of their dimensions
      ALLOCATE(FREQ(NHC),NFACT(NHC),EQARG(NHC),HCNAME(NHC))
      ALLOCATE(EAMP(3,NHC),EPHA(3,NHC))
      if (includeVelocity.eqv..true.) then     
         ALLOCATE(UAMP(3,NHC),UPHA(3,NHC))
         ALLOCATE(VAMP(3,NHC),VPHA(3,NHC))
      endif
      if (.not.allocated(interpTidalConstituents)) then
         allocate(interpTidalConstituents(numTidalConstituents))
         interpTidalConstituents(1:7) = defaultTidalConstituents(1:7)
      endif
C...
C...  OUTPUT FILE HEADER
      if (adcircFormat.eqv..false.) then
         WRITE(1,3900)
 3900    FORMAT(//,8X,'Constituent',13x,'Elevation',16x,'East Velocity',
     &          12X,'North Velocity')
         WRITE(1,3901)
 3901    FORMAT(11x,'Name/',8x,3(6x,'Amplitude     Phase'))
         WRITE(1,3902)
 3902    FORMAT(5X,'Lon',10X,'Lat',12X,'(m)',8X,'(deg)',2(9x,'(m/s)',6X,
     &                                                  '(deg)'),/)
      endif
C
C...
C...  READ TARGET LOCATIONS FOR HARMONIC ANALYSIS OUTPUT
      read(12,*) header
      read(12,*) tne,tnp
      allocate(node(tnp),xlon(tnp),ylat(tnp),depth(tnp))
      do n=1,tnp
         read(12,*) node(n),xlon(n),ylat(n),depth(n)
         if(xlon(n).lt.-180.) xlon(n)=xlon(n)+360.
         if(xlon(n).ge.180.) xlon(n)=xlon(n)-360.
      end do
C
      do n=1,tne
         read(12,*) en,idum,i1,i2,i3 ! skip past the element table
      end do
      read(12,*) nope
      read(12,*) neta
      nout=neta
      allocate(tnode(nout),xout(nout),yout(nout),depthout(nout))
      n=0
      do k=1,nope
         read(12,*) nvdll
         do i=1,nvdll
            n=n+1
            read(12,*) tnode(n)
            end do
         end do
      if(n.ne.neta) then
         write(*,*) "ERROR: ec2001v2d_tide_interp: ",
     &   "the number of open boundary nodes (",n,
     &   "), in the target mesh file '",
     &   trim(targetmesh),"' not match NETA (",neta,
     &   ") in the target mesh file."
         write(*,*) ' '
         stop
      endif
      do n=1,nout
         xout(n)=xlon(tnode(n)) ! assumes the nodes are in order at top of file
         yout(n)=ylat(tnode(n))
         depthout(n)=depth(tnode(n))
      end do
      close(12)
      ! write a log message with the node locations where the tides will be
      ! interpolated (i.e., target locations)
      DO I=1,NOUT
         WRITE(2,1000) XOUT(I),YOUT(I)
 1000   FORMAT('OUTPUT WILL BE GENERATED FOR THE POSITION ',
     &            F11.6,' E LONGITUDE, ',F11.6,' N LATITUDE.')
      END DO
C...
C...  read source mesh where tidal data are stored
      READ(14,'(A24)') AGRID
      READ(14,*) NE,NP
      ALLOCATE(X(NP),Y(NP))
      ALLOCATE(ETAMP(NHC,NOUT),ETPHA(NHC,NOUT))
      if (includeVelocity.eqv..true.) then
         ALLOCATE(UTAMP(NHC,NOUT),UTPHA(NHC,NOUT))
         ALLOCATE(VTAMP(NHC,NOUT),VTPHA(NHC,NOUT))
      endif
      ALLOCATE(NM1(NE),NM2(NE),NM3(NE))
C
C...  NODAL COORDINATES
      write(2,'(a)') 'INFO: Reading nodal coordinates from source mesh.'
      DO I=1,NP
        READ(14,*) JKI,X(JKI),Y(JKI)
      END DO
C
C.... CONNECTIVITY TABLE 
      write(2,'(a)') 'INFO: Reading element table from source mesh.'
      do i=1,ne
         read(14,*) jki, nhy, nm1(jki), nm2(jki), nm3(jki)
      end do
      close(14)
C...
C.... COMPUTE ELEMENT IN WHICH EACH LOCATION LIES.
      write(2,'(a)') 'INFO: Computing locations and interpolating.'
      DO I=1,NOUT
         AEMIN=1.0E+25
         KMIN=0
         X4=XOUT(I)
         Y4=YOUT(I)
         DO K=1,NE
            X1=X(NM1(K))
            X2=X(NM2(K))
            X3=X(NM3(K))
            Y1=Y(NM1(K))
            Y2=Y(NM2(K))
            Y3=Y(NM3(K))
            AREAS=(X1-X3)*(Y2-Y3)-(X3-X2)*(Y3-Y1)
            A1=(X4-X3)*(Y2-Y3)-(X3-X2)*(Y3-Y4)
            A2=(X1-X3)*(Y4-Y3)-(X3-X4)*(Y3-Y1)
            A3=(X1-X4)*(Y2-Y4)-(X4-X2)*(Y4-Y1)
            AA=ABS(A1)+ABS(A2)+ABS(A3)
            AE=ABS(AA-AREAS)/AREAS
            IF(AE.LT.AEMIN) THEN
               AEMIN=AE
               NNE=K
               N1=NM1(K)
               N2=NM2(K)
               N3=NM3(K)
               AREA=AREAS
            ENDIF
         END DO

C......  PRINT WARNING IF NODE OUTSIDE THE DOMAIN

         IF(AEMIN.GT.1.0E-5) THEN                  !OUTSIDE AN ELEMENT
            WRITE(*,2000) AEMIN
            WRITE(2,2000) AEMIN
 2000      FORMAT(' WARNING: ec2001v2d_tide_interp:', 
     &           ' SPECIFIED LOCATION DOES NOT LIE',
     &           ' WITHIN ANY ELEMENT IN THE DOMAIN.',/,' CHECK THE',
     &           ' LONGITUDE AND LATITUDE FOR THIS LOCATION',
     &           ' PROGRAM WILL ESTIMATE NEAREST ELEMENT',/,' THE',
     &           ' PROXIMITY INDEX FOR THIS LOCATION EQUALS ',E15.6)
         ENDIF

C......  COMPUTE INFORMATION REQUIRED TO INTERPOLATE AT OUTPUT LOCATION

         X1=X(N1)
         X2=X(N2)
         X3=X(N3)
         Y1=Y(N1)
         Y2=Y(N2)
         Y3=Y(N3)
         STA2=((X4-X1)*(Y3-Y1)-(Y4-Y1)*(X3-X1))/AREA
         STA3=(-(X4-X1)*(Y2-Y1)+(Y4-Y1)*(X2-X1))/AREA
         STA1=1.d0-STA2-STA3

C......  DETERMINE ASCENDING ORDER OF NODES
C        we need the node numbers in ascending order because we will
C        be reading them from the ascii tidal database and they will be 
C        found in ascending order
         IF((N1.LT.N2).AND.(N2.LT.N3)) THEN
            NN(1)=N1
            NN(2)=N2
            NN(3)=N3
            NO(1)=1
            NO(2)=2
            NO(3)=3
            GOTO 200
         ENDIF
         IF((N2.LT.N1).AND.(N1.LT.N3)) THEN
            NN(1)=N2
            NN(2)=N1
            NN(3)=N3
            NO(2)=1
            NO(1)=2
            NO(3)=3
            GOTO 200
         ENDIF
         IF((N1.LT.N3).AND.(N3.LT.N2)) THEN
            NN(1)=N1
            NN(2)=N3
            NN(3)=N2
            NO(1)=1
            NO(3)=2
            NO(2)=3
            GOTO 200
         ENDIF
c        Bug fix for v 1.05 on 3-22-99 starts here:
         IF((N2.LT.N3).AND.(N3.LT.N1)) THEN
            NN(1)=N2
            NN(2)=N3
            NN(3)=N1
            NO(3)=1
            NO(1)=2
            NO(2)=3
            GOTO 200
         ENDIF
         IF((N3.LT.N1).AND.(N1.LT.N2)) THEN
            NN(1)=N3
            NN(2)=N1
            NN(3)=N2
            NO(2)=1
            NO(3)=2
            NO(1)=3
            GOTO 200
         ENDIF
c        End of bug fix (the above definitions of NO(.) were switched in previous version
         IF((N3.LT.N2).AND.(N2.LT.N1)) THEN
            NN(1)=N3
            NN(2)=N2
            NN(3)=N1
            NO(3)=1
            NO(2)=2
            NO(1)=3
            GOTO 200
         ENDIF
C
C...... WRITE THE ELEMENT CONTAINING THE OUTPUT LOCATION
  200    WRITE(2,2100) NNE,NN(1),NN(2),NN(3)
 2100    FORMAT(' SPECIFIED LOCATION WAS FOUND IN ELEMENT ',I0,
     &      ' WHICH IS MADE UP OF NODES ',3(I0,1x))
 3200   FORMAT(//)
C
C......  Read tidal constituent information from tidal database
         READ(105,*) NHC  ! number of tidal constituents in the tidal database
         DO J=1,NHC
           READ(105,'(E21.10,F11.7,F13.8,2X,A10)') 
     &         FREQ(J),NFACT(J),EQARG(J),HCNAME(J)
         END DO
         READ(105,*) NPP ! number of nodes in the tidal database mesh
         !
         ! the following code is a very complicated way of skipping down
         ! through the file to find the right node numbers
         DO K=1,3  ! three nodes in source element
            IBEG=1
            IF(K.GE.2) IBEG=NN(K-1)+1
            DO II=IBEG,NN(K)-1 ! skip down through the tidal database file
               if (includeVelocity.eqv..true.) then
                  READ(105,3200)  ! skip two lines (for u and v)
               else
                  read(105,'(a)') cmdlinearg ! skip one line (for eta)
               endif
            END DO
            ! the code above skips down to the line just before the line 
            ! we want; now read the data we are interested in
            READ(105,*) SNODE,(EAMP(NO(K),J),EPHA(NO(K),J),J=1,NHC) ! source node
            if (includeVelocity.eqv..true.) then
               READ(105,*)       (UAMP(NO(K),J),UPHA(NO(K),J),J=1,NHC)
               READ(105,*)       (VAMP(NO(K),J),VPHA(NO(K),J),J=1,NHC)
            endif
            IF(SNODE.NE.NN(K)) THEN ! failed to skip to the right node
              WRITE(*,'(a,i0,a,i0,a)') 'ERROR: While searching for node ',
     &           NN(K),', the node ',SNODE,' was found instead.'
               STOP
            ENDIF
            DO J=1,NHC
               EPHA(NO(K),J)=PI*EPHA(NO(K),J)/180.
               if (includeVelocity.eqv..true.) then
                  UPHA(NO(K),J)=PI*UPHA(NO(K),J)/180.
                  VPHA(NO(K),J)=PI*VPHA(NO(K),J)/180.
               endif
            END DO
         END DO

         REWIND(105)

C......  COMPUTE HARMONIC CONSTITUENTS AT THE OUTPUT LOCATION

         DO J=1,NHC
            E1R=EAMP(1,J)*COS(EPHA(1,J))
            E1I=EAMP(1,J)*SIN(EPHA(1,J))
            E2R=EAMP(2,J)*COS(EPHA(2,J))
            E2I=EAMP(2,J)*SIN(EPHA(2,J))
            E3R=EAMP(3,J)*COS(EPHA(3,J))
            E3I=EAMP(3,J)*SIN(EPHA(3,J))
            ETR=E1R*STA1+E2R*STA2+E3R*STA3
            ETI=E1I*STA1+E2I*STA2+E3I*STA3
            ETAMP(J,I)=SQRT(ETR*ETR+ETI*ETI)
            IF(ETAMP(J,I).EQ.0.) THEN
               ETPHA(J,I)=0.
            ELSE
               ETPHA(J,I)=180.*ACOS(ETR/ETAMP(J,I))/PI
               IF(ETI.LT.0.) ETPHA(J,I)=360.-ETPHA(J,I)
            ENDIF
            if (includeVelocity.eqv..true.) then
               U1R=UAMP(1,J)*COS(UPHA(1,J))
               U1I=UAMP(1,J)*SIN(UPHA(1,J))
               U2R=UAMP(2,J)*COS(UPHA(2,J))
               U2I=UAMP(2,J)*SIN(UPHA(2,J))
               U3R=UAMP(3,J)*COS(UPHA(3,J))
               U3I=UAMP(3,J)*SIN(UPHA(3,J))
               V1R=VAMP(1,J)*COS(VPHA(1,J))
               V1I=VAMP(1,J)*SIN(VPHA(1,J))
               V2R=VAMP(2,J)*COS(VPHA(2,J))
               V2I=VAMP(2,J)*SIN(VPHA(2,J))
               V3R=VAMP(3,J)*COS(VPHA(3,J))
               V3I=VAMP(3,J)*SIN(VPHA(3,J))
               UTR=U1R*STA1+U2R*STA2+U3R*STA3
               UTI=U1I*STA1+U2I*STA2+U3I*STA3
               VTR=V1R*STA1+V2R*STA2+V3R*STA3
               VTI=V1I*STA1+V2I*STA2+V3I*STA3
               UTAMP(J,I)=SQRT(UTR*UTR+UTI*UTI)
               VTAMP(J,I)=SQRT(VTR*VTR+VTI*VTI)
               IF(UTAMP(J,I).EQ.0.) THEN
                  UTPHA(J,I)=0.
               ELSE
                  UTPHA(J,I)=180.*ACOS(UTR/UTAMP(J,I))/PI
                  IF(UTI.LT.0.) UTPHA(J,I)=360.-UTPHA(J,I)
               ENDIF
               IF(VTAMP(J,I).EQ.0.) THEN
                  VTPHA(J,I)=0.
               ELSE
                  VTPHA(J,I)=180.*ACOS(VTR/VTAMP(J,I))/PI
                  IF(VTI.LT.0.) VTPHA(J,I)=360.-VTPHA(J,I)
               ENDIF
            endif
         END DO
      END DO

C......WRITE THE RESULTS
      if (numTidalConstituents.eq.0) then
         ! write all the constituents in the database
         allocate(constituentList(nhc))
         do i=1,nhc
            constituentList(i) = i
         end do
         numTidalConstituents = nhc
      else
         ! if a list of tidal constituents was specified, then only 
         ! output the interpolated values of the specified constituents
         allocate(constituentList(numTidalConstituents))     
         do j=1,numTidalConstituents
            do k=1,nhc           
               if (trim(adjustl(interpTidalConstituents(j)))
     &                   == trim(adjustl(hcname(k))) ) then
                  constituentList(j) = k
                  exit
               endif
            end do
         end do
      endif
      do k=1,numTidalConstituents
         j = constituentList(k)
         if ((adcircFormat.eqv..true.).and.(k.eq.1)) then
            write(1,'(a,10x,i0,6x,"! NBFR: num freqencies on ocean boundary; interpolated by ASGS from ",a," using ec2001v2d_tide_interp.f")') 
     &         trim(adjustl(hcname(j))),numTidalConstituents, trim(tidaldb)
         else
            write(1,'(a)') trim(adjustl(hcname(j)))
         endif
         do i=1,nout
            if (adcircFormat.eqv..true.) then
               if (includeVelocity.eqv..true.) then
                  write(1,4010) etamp(j,i),etpha(j,i),
     &                    utamp(j,i),utpha(j,i),vtamp(j,i),vtpha(j,i),tnode(i),xout(i),yout(i),depthout(i)
               else            
                  write(1,5010) etamp(j,i),etpha(j,i),tnode(i),xout(i),yout(i),depthout(i)
               endif
            else  ! include 
               if (includeVelocity.eqv..true.) then
                  write(1,4000) xout(i),yout(i),etamp(j,i),etpha(j,i)
     &                    ,utamp(j,i),utpha(j,i),vtamp(j,i),vtpha(j,i),tnode(i),xout(i),yout(i),depthout(i)
               else
                  write(1,4000) xout(i),yout(i),etamp(j,i),etpha(j,i),tnode(i),xout(i),yout(i),depthout(i)
               endif
            endif
         end do
      end do

      WRITE(*,4100) trim(outfile)
      CLOSE(1)
      CLOSE(2)
      CLOSE(105)
 4000 FORMAT(1X,2(F11.6,2X),3(E12.5,2X,F8.3,3X),'  ! node ',i0,' lon ',F11.6,' lat ',F11.6,' depth ',F11.6)
 4010 FORMAT(1X,3(E12.5,2X,F8.3,3X),'  ! node ',i0,' lon ',F11.6,' lat ',F11.6,' depth ',F11.6)
 5010 FORMAT(1X,E12.5,2X,F8.3,'  ! node ',i0,' lon ',F11.6,' lat ',F11.6,' depth ',F11.6) 
 4100 FORMAT("INFO: ec2001v2d_tide_interp: ",
     &  "RESULTS HAVE BEEN STORED IN FILE: '",A,"'.")
!     -----------------------------------------------------------------
      end program ec2001v2d_tide_interp
!     -----------------------------------------------------------------
